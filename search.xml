<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go</title>
      <link href="/2023/02/01/Go/"/>
      <url>/2023/02/01/Go/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/01/hello-world/"/>
      <url>/2023/02/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/01/17/TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2023/01/17/TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP握手机制"><a href="#TCP握手机制" class="headerlink" title="TCP握手机制"></a>TCP握手机制</h2><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114103918.png" alt="image-20230117114103918"></p><h2 id="端口转发绕过防火墙"><a href="#端口转发绕过防火墙" class="headerlink" title="端口转发绕过防火墙"></a>端口转发绕过防火墙</h2><ul><li><p>某些情况下，可以使用中间系统代理连接绕过或穿透防火墙从而避开这些限制，这种技术被称为<strong>端口转发</strong></p></li><li><p>许多企业网络限制内部资产建立与恶意站点的H∏P连接。假设有一个名为evil.com的恶意网站，如果有员工尝试直接测览evil.com，则防火墙会阻止该请求°但是,如果员工拥有允许通过防火墙的外部系统（例如stacktitan.com），则该员工可以利用允许的域来反弹与evil.com的连接</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114441819.png" alt="image-20230117114441819"></p></li><li><p>可以使用端口转发绕过多种限制性网络配置。例如：可以通过跳箱转发流量，以访问分段网络或访问绑定到限制性接口的端口</p></li></ul><h2 id="编写一个TCP扫描器"><a href="#编写一个TCP扫描器" class="headerlink" title="编写一个TCP扫描器"></a>编写一个TCP扫描器</h2><h4 id="要使用的包"><a href="#要使用的包" class="headerlink" title="要使用的包"></a>要使用的包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.Dial(network, address <span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>第一个参数是一个字符串，用于标识要启动的连接的类型。这是因为Dil不仅适用于TCP,它还可以用于创建使用UNIX套接字、UDP和第4层协议的连接。你可以使用其他字符串，但为简洁起见，这里将使用字符串tcp。</li></ul><h4 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h4><h5 id="仅扫描一个端口"><a href="#仅扫描一个端口" class="headerlink" title="仅扫描一个端口"></a>仅扫描一个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;scanme.nmap.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Connection successful&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描1024个端口"><a href="#扫描1024个端口" class="headerlink" title="扫描1024个端口"></a>扫描1024个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发版本"><a href="#并发版本" class="headerlink" title="并发版本"></a>并发版本</h4><h5 id="“极速”的端口扫描"><a href="#“极速”的端口扫描" class="headerlink" title="“极速”的端口扫描"></a>“极速”的端口扫描</h5><ul><li>运行完上面代码后，程序几乎立刻退出了。</li><li>刚才运行的代码会为每个连接启动一个goroutine，而主goroutine并不知道要等待连<br>接发生。因此，代码在for循环完成迭代后回退出。</li><li>这可能比代码与目标端口之间的数据包网络交换还要快。对于数据包仍在运行的端口，可能无法获得其准确的结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解决方案：</p><ol><li><p>使用sync包中的WajtGroup进行同步扫描</p></li><li></li></ol></li></ul><h5 id="使用WaitGroup进行同步扫描"><a href="#使用WaitGroup进行同步扫描" class="headerlink" title="使用WaitGroup进行同步扫描"></a>使用WaitGroup进行同步扫描</h5><ul><li>创建WaitGroup后，可以在此结构体上调用一些方法。第一个是Add(i),它将按所提供的数字递增内部计数器。接下来，Done()将计数器减1。最后，Wait()会阻止在其中调用它的goroutine的执行，并且在内部计数器达到零之前将不允许进一步执行。你可以组合这些调用以确保主goroutine等待所有连接完成。</li><li>该程序比初始版本有了进步，但仍然不算是正确的。如果对多个主机多次执行此程<br>序，则可能会看到不一致的结果</li><li>同时扫描过多的主机或端口可能会导致网络或系统限制，造成结果不正确</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">//2    通过wg.Add(1)递增计数器</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">//3      只要执行对一个端口的扫描，对wg.Done()的延迟调用就会使计数器递减</span></span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">//4   阻塞main函数，直到所有工作完成并且计数器值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用工人池进行端口扫描"><a href="#使用工人池进行端口扫描" class="headerlink" title="使用工人池进行端口扫描"></a>使用工人池进行端口扫描</h5><ul><li>为避免结果不一致，我们需要使用goroutine池管理正在进行的并发工作。使用for循环创建一定数量的工人goroutine作为资源池：然后，在main()线程中使用通道提供工作。</li><li>有趣的现象:数字不是以特定的顺序打印的；欢迎来到精彩的并行世界。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"></span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//创建管道，缓冲区为100</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> worker(ports, &amp;wg)   <span class="comment">//并发工作，再收到ports&lt;-i才会开始工作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      ports &lt;- i</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   <span class="built_in">close</span>(ports) <span class="comment">//关闭管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终版本：多通道通信"><a href="#最终版本：多通道通信" class="headerlink" title="最终版本：多通道通信"></a>最终版本：多通道通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, p)</span><br><span class="line">      conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          results &lt;- <span class="number">0</span>  <span class="comment">//没有打开的端口送给results管道赋值0(总感觉有点低效)</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      conn.Close()  <span class="comment">//关闭连接</span></span><br><span class="line">      results &lt;- p  <span class="comment">//打开的端口送给results管道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">   results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//没有限制</span></span><br><span class="line">   <span class="keyword">var</span> openports []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;  <span class="comment">//100个工人疯狂工作哈哈</span></span><br><span class="line">      <span class="keyword">go</span> worker(ports, results)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//1024个端口号传入ports管道</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">         ports &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123; <span class="comment">//从results管道取出数据</span></span><br><span class="line">      port := &lt;-results</span><br><span class="line">      <span class="keyword">if</span> port != <span class="number">0</span> &#123;</span><br><span class="line">         openports = <span class="built_in">append</span>(openports, port)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(ports)  <span class="comment">//关闭管道</span></span><br><span class="line">   <span class="built_in">close</span>(results)</span><br><span class="line">   sort.Ints(openports)  <span class="comment">//对开启的端口做个排序</span></span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> openports &#123; <span class="comment">//输出</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, port)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造TCP代理"><a href="#构造TCP代理" class="headerlink" title="构造TCP代理"></a>构造TCP代理</h2><h3 id="io-Reader和io-Writer"><a href="#io-Reader和io-Writer" class="headerlink" title="io.Reader和io.Writer"></a>io.Reader和io.Writer</h3><ul><li><p>对于I&#x2F;0任务来说，这两种数据类型是必不可少的</p></li><li><p>&#96;&#96;&#96;go<br>type Reader interface {<br>Read(p []byte) (n int, err error)<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自定义包装实现接口</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  type FooWriter struct &#123;&#125;</span><br><span class="line">  func (fooWriter *FooWriter) Write(p []byte) (int, error)&#123;</span><br><span class="line">      return len(dataWrittenSomewhere), nil</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="reader和Writer演示"><a href="#reader和Writer演示" class="headerlink" title="reader和Writer演示"></a>reader和Writer演示</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myreader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*myreader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;read:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdin.Read(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> mywriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*mywriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;write:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      r myreader</span><br><span class="line">      w mywriter</span><br><span class="line">   )</span><br><span class="line">   input := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">   read, err := r.Read(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;read %d from stdin\n&quot;</span>, read)</span><br><span class="line">   write, err := w.Write(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;write %d from stdout\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><blockquote><p>read:<br>hello 2023!!!<br>read 15 from stdin<br>write:<br>hello 2023!!!<br>write 1024 from stdout</p></blockquote><h4 id="io-Copy"><a href="#io-Copy" class="headerlink" title="io.Copy()"></a>io.Copy()</h4><ul><li>将数据从Reader复制到Writer是一种非常常见的模式,这促使Go的io包中提供一个函数Copy()该函数可用于简化函数main()函数Copy()原型如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119105051430.png" alt="image-20230119105051430"></p><h3 id="创建回显-echo-服务器"><a href="#创建回显-echo-服务器" class="headerlink" title="创建回显(echo)服务器"></a>创建回显(echo)服务器</h3><h5 id="基本回显server-go"><a href="#基本回显server-go" class="headerlink" title="基本回显server.go"></a>基本回显server.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      size, err := conn.Read(b[<span class="number">0</span>:])</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;Client disconnected&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != err &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;connection error&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.Printf(<span class="string">&quot;recerved %d bytes :%s\n&quot;</span>, size, <span class="type">string</span>(b))\</span><br><span class="line">      <span class="comment">//conn.Write()发送数据</span></span><br><span class="line">      _, err = conn.Write(b[<span class="number">0</span>:size])</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8888&quot;</span>)</span><br><span class="line">   log.Println(<span class="string">&quot;listning on 0.0.0.0:8888&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//等待连接，在已建立连接创建net.conn</span></span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="comment">//并发</span></span><br><span class="line">      <span class="keyword">go</span> echo(conn)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="改进：加入带缓冲的监听器"><a href="#改进：加入带缓冲的监听器" class="headerlink" title="改进：加入带缓冲的监听器"></a>改进：加入带缓冲的监听器</h5><ul><li>依赖相当低级的函数调用、缓冲区跟踪以及重复的R&#x2F;W。</li><li>运行过程很乏味且容易出错</li><li>使用bufio包包装了Reader和Writer，并且有I&#x2F;O缓冲机制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   reader := bufio.NewReader(conn)</span><br><span class="line">   s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(<span class="string">&quot;read %d bytes: %s\n&quot;</span>, <span class="built_in">len</span>(<span class="type">string</span>(s), s))</span><br><span class="line"></span><br><span class="line">   writer := bufio.NewWriter(conn)</span><br><span class="line">   <span class="keyword">if</span> _, err := writer.WriteString(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to write data&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   writer.Flush() <span class="comment">//关闭写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Copy-进一步简化"><a href="#使用Copy-进一步简化" class="headerlink" title="使用Copy()进一步简化"></a>使用Copy()进一步简化</h5><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119142006472.png" alt="image-20230119142006472"></p><h3 id="代理一个tcp客户端"><a href="#代理一个tcp客户端" class="headerlink" title="代理一个tcp客户端"></a>代理一个tcp客户端</h3><ul><li>本地主机(公司内网)&lt;-&gt;个人服务器(joesproxy.com)&lt;-&gt;目标站点(joescatcam.website)</li><li><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214430613.png" alt="image-20230119214430613"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(src net.Conn)</span></span> &#123;</span><br><span class="line">   dst, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;joescatcam.website:80&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to connnerct to our unreachable host&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在goroutine中运行以防止io.Copy被阻塞</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//将源的输出复制到目标 dst = src</span></span><br><span class="line">      <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//将目标的输出复制回源 src = dst</span></span><br><span class="line">   <span class="keyword">if</span> _, err := io.Copy(src, dst); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:80&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="keyword">go</span> handle(conn)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214317336.png" alt="image-20230119214317336"></p><h3 id="复现Netcat命令执行"><a href="#复现Netcat命令执行" class="headerlink" title="复现Netcat命令执行"></a>复现Netcat命令执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lp <span class="number">8888</span> -e /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Flusher包装bufio.Writer，显式刷新所有写入</span></span><br><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">struct</span> &#123;</span><br><span class="line">   w *bufio.Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewFlusher从io.Writer创建一个新的Flusher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFlusher</span><span class="params">(w io.Writer)</span></span> *Flusher &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Flusher&#123;w: bufio.NewWriter(w)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo *Flusher)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   count, err := foo.w.Write(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := foo.w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="comment">//显示调用/bin/sh并使用-i进入交互模式</span></span><br><span class="line">   <span class="comment">//这样就可以把它作为标准输入和标准输出</span></span><br><span class="line">   <span class="comment">//对于Windows：exec.Command(&quot;cmd.exe&quot;)</span></span><br><span class="line">   cmd := exec.Command(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">   cmd.Stdin = conn</span><br><span class="line">   <span class="comment">//从连接创建一个Flusher用于标准输出</span></span><br><span class="line">   <span class="comment">//这样可以确保标准输出被充分刷新并通过met.Conn发送</span></span><br><span class="line">   cmd.Stdout = NewFlusher(conn)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//运行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的解决方案虽然可行，但不够优雅。</li><li>学习io.Pipe()函数，该函数时Go的同步内存管道。可用于连接Reader和Writer</li><li>func Pipe() (*PipeReader, *PipeWriter)</li><li>将PipeReader链接到TCP连接。可使<br>用goroutine防止代码被阻塞。命令的任何标准输出都将发送到writer，然后通过管道传<br>送到reader并通过TCP连接输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    cmd := exex.Command(<span class="string">&quot;cmd.exe&quot;</span>)<span class="comment">//&quot;/bin/sh&quot;, &quot;-i&quot;</span></span><br><span class="line">    <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">    rp, wp := io.Pipe()</span><br><span class="line">    cmd.Stdin = conn</span><br><span class="line">    cmd.Stdout = wp</span><br><span class="line">    <span class="keyword">go</span> io.Copy(conn, rp)</span><br><span class="line">    cmd.Run()</span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
